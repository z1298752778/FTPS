package com.leateck.phase.materialalternativeidentification0010;

import com.datasweep.compatibility.client.*;
import com.datasweep.plantops.common.measuredvalue.IMeasuredValue;
import com.datasweep.plantops.common.measuredvalue.IUnitOfMeasure;
import com.jgoodies.common.base.Strings;
import com.leateck.parameter.materialpositioncontrol0010.MESParamMatPositionCtr0100;
import com.rockwell.mes.apps.ebr.ifc.phase.IPhaseCompleter;
import com.rockwell.mes.apps.ebr.ifc.phase.ui.PhaseQuestionDialog;
import com.rockwell.mes.apps.ebr.ifc.phase.ui.PhaseWarningDialog;
import com.rockwell.mes.clientfw.pec.ifc.dialog.ErrorDialogWithDetails;
import com.rockwell.mes.commons.base.ifc.IExceptionHandler;
import com.rockwell.mes.commons.base.ifc.OSILock;
import com.rockwell.mes.commons.base.ifc.OSILockCollection;
import com.rockwell.mes.commons.base.ifc.exceptions.MESException;
import com.rockwell.mes.commons.base.ifc.exceptions.MESIncompatibleUoMException;
import com.rockwell.mes.commons.base.ifc.exceptions.MESInvalidBarcodeException;
import com.rockwell.mes.commons.base.ifc.exceptions.MESRuntimeException;
import com.rockwell.mes.commons.base.ifc.functional.IMeasuredValueConverter;
import com.rockwell.mes.commons.base.ifc.functional.MeasuredValueUtilities;
import com.rockwell.mes.commons.base.ifc.i18n.I18nMessageUtility;
import com.rockwell.mes.commons.base.ifc.nameduda.MESNamedUDAOrderStepInput;
import com.rockwell.mes.commons.base.ifc.nameduda.MESNamedUDASublot;
import com.rockwell.mes.commons.base.ifc.services.PCContext;
import com.rockwell.mes.commons.base.ifc.services.ServiceFactory;
import com.rockwell.mes.commons.base.ifc.sql.DataBaseLockUtility;
import com.rockwell.mes.commons.base.ifc.utility.*;
import com.rockwell.mes.commons.deviation.ifc.IESignatureExecutor;
import com.rockwell.mes.commons.deviation.ifc.exceptionrecording.IMESExceptionRecord;
import com.rockwell.mes.commons.parameter.exceptiondef.MESParamExceptionDef0300;
import com.rockwell.mes.parameter.product.excptenabledef.MESParamExcptEnableDef0200;
import com.rockwell.mes.services.commons.ifc.functional.PartRelatedMeasuredValueUtilities;
import com.rockwell.mes.services.inventory.ifc.IMFCService;
import com.rockwell.mes.services.inventory.ifc.ISublotService;
import com.rockwell.mes.services.inventory.ifc.TransactionHistoryContext;
import com.rockwell.mes.services.inventory.ifc.TransactionSubtype;
import com.rockwell.mes.services.inventory.ifc.checks.ExecuteCheckParameter;
import com.rockwell.mes.services.inventory.ifc.checks.IIdentificationCheck;
import com.rockwell.mes.services.inventory.ifc.checks.IIdentificationCheckSuite;
import com.rockwell.mes.services.inventory.ifc.exceptions.MESQuantityExceedsAllowedVariationException;
import com.rockwell.mes.services.inventory.ifc.exceptions.MESQuantityMustNotBeNegativeException;
import com.rockwell.mes.services.inventory.ifc.exceptions.MESSublotOperationNotAllowedException;
import com.rockwell.mes.services.s88.ifc.IS88ExecutionService;
import com.rockwell.mes.services.s88.ifc.execution.IMESRtPhase;
import com.rockwell.mes.services.s88.ifc.recipe.IMESMaterialParameter;
import com.rockwell.mes.services.s88.ifc.recipe.IMESPhase;
import com.rockwell.mes.services.s88.ifc.recipe.PlannedQuantityMode;
import com.rockwell.mes.services.warehouseintegration.ifc.WarehouseRuntimeException;
import com.rockwell.mes.services.wip.ifc.*;
import com.rockwell.mes.services.wip.ifc.exceptions.MESMultipleSublotsIdentificationException;
import com.rockwell.mes.shared.product.material.*;
import com.rockwell.mes.shared.product.material.choicelist.ChoiceLists0710;
import com.rockwell.mes.shared.product.material.ident.IPhaseIdentificationCheckSuite0710;
import com.rockwell.mes.shared.product.material.messaging.MatIdentMessage0710Controller;
import com.rockwell.mes.shared.product.material.util.MaterialHelper0710;
import com.rockwell.mes.shared0200.product.datatypes.MeasuredValueWrapper;
import com.rockwell.mes.shared0400.product.ui.basics.util.ProductPhaseSwingHelper;
import com.rockwell.mes.shared0400.product.util.ParamClassConstants0400;
import com.rockwell.mes.commons.deviation.ifc.exceptionrecording.IMESExceptionRecord.RiskClass;

import org.apache.commons.collections.MapUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.math.BigDecimal;
import java.nio.charset.Charset;
import java.util.*;

import java.util.function.BiConsumer;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * TODO: Please enter the description of this type. This is mandatory!
 * <p>
 * This runtime phase executor skeleton is generated by the PhaseLibManager.
 * <p>
 * <p>
 * TODO: @author UserName, (c) Copyright 2010 Rockwell Automation Technologies, Inc.
 * All Rights Reserved.
 */
public class RtPhaseExecutorMatAlterIdent0010 extends AbstractMaterialPhaseExecutor0710<MatIdentModel0710, MatIdentView0710, MatIdentExceptionView0710, //
        ActionView0710> implements IMatIdentEventListener0710 {

    /**
     * work around to clear blob column
     */
    static final String WORK_AROUND_BLOB_VALUE_FOR_EMPTY = " ";

    /**
     * the check key of manual identification on exception
     */
    public static final String KEY_MANUAL_EXC = "ManualIdentException";

    /**
     * the check key of undo identification on exception
     */
    public static final String KEY_UNDO_EXC = "UndoIdentException";

    /**
     * the check key of additional identification on action
     */
    public static final String KEY_ADDITIONAL_ACTION = "AdditionalIdentAction";

    /**
     * the check key of undo identification on action
     */
    public static final String KEY_UNDO_ACTION = "UndoIdentAction";

    /**
     * the check key of identification with exceptions to be signed
     */
    public static final String KEY_IDENTIFICATION = "Identification";

    private static final String PARAM_FORCE_COMPLETION = "Force completion";

    /**
     * the check key of force completion with exceptions to be signed
     */
    public static final String KEY_FORCE_COMPLETION = "ForceCompletion";

    /**
     * The name of the message pack containing messages needed for this phase
     */
    public static final String MSG_PACK = "LC_PhaseIdentifyMaterial0010";

    public static final String KEY_MATERIAL_HYBRID_EXCEPTION = "MaterialHybridException";
    public static final String KEY_PROPORTIONALANOMALY = "ProprtionAlanomaly";
    public static final String KEY_INSUFFICIENTRECOGNITIONQUANTITY = "InsufficientrecognitionQuantity";
    private static final String CONSUME_SUBLOT_WAREHOUSE_ERROR_MSG_ID = "ConsumeSublotWarehouseError_Error";

    private static final Log LOGGER = LogFactory.getLog(RtPhaseExecutorMatAlterIdent0010.class);

    /**
     * list of identification checks configured in process parameters which result in an error
     */
    private IPhaseIdentificationCheckSuite0710 identCheckSuite;

    private final List<String> sublotNamesForUndoLUIdentifucation = new ArrayList<>();

    private final List<Sublot> sublotsForUndoLUIdentification = new ArrayList<>();

    private MatIdentMessage0710Controller messageController;

    private IIdentifiedItem0710 identifiedItem;

    private MESParamExcptEnableDef0200 locationViolationException;
    private MESParamExcptEnableDef0200 sequenceViolationException;
    private MESParamExcptEnableDef0200 openExpirationViolation;

    private MESParamExcptEnableDef0200 mixCheckConfiguration;

    public static final String KEY_LOCATION_VIOLATION_EXCEPTION = "Location Violation Exception";
    public static final String KEY_SEQUENCE_VIOLATION_EXCEPTION = "Sequence Violation Exception";
    public static final String KEY_OPEN_EXPIRATION_VIOLATION_EXCEPTION = "Open Expiration Violation Exception";

    public final Map<String, List<String>> sclCheckExceptionMessage = new HashMap<>();
    public final Map<String, MESParamExcptEnableDef0200> sclKeyExceptionMap = new HashMap<String, MESParamExcptEnableDef0200>();

    private final static  Map<Integer,String> materialTypeFinal = new HashMap<Integer,String>();
    public static String mainMaterial;
    public static String combineGroupName;

    public static OrderStepInput masterOsiException = null;
    List<IMESMaterialParameter> materialParametersException = null;
    public static MeasuredValue totalConsumedQtyException = null;
    public static final String PROPORTIONALANOMALY = "Proportional anomaly";

    public static final String INSUFFICIENTRECOGNITIONQUANTITY = "Insufficient recognition quantity";
    public static final String MATERIALLIMITMODE = "Material Limit mode";

    /**
     * ctor for an ACTIVE phase or a COMPLETED phase in case of resume.
     *
     * @param inPhaseCompleter the object, which shall be used to complete the phase
     * @param inRtPhase        the runtime phase to be executed
     */
    public RtPhaseExecutorMatAlterIdent0010(IPhaseCompleter inPhaseCompleter, IMESRtPhase inRtPhase) {
        super(inPhaseCompleter, inRtPhase);
    }

    /**
     * ctor for a phase for the PREVIEW.
     *
     * @param inPhase the related phase
     * @param inStep  the related activity set step
     */
    public RtPhaseExecutorMatAlterIdent0010(IMESPhase inPhase, ActivitySetStep inStep) {
        super(inPhase, inStep);
    }

    @Override
    protected void start() {
        initChecks();
        if (generateReportData()) {
            saveRtPhase();
        }
        materialTypeFinal.clear();
        messageController = new MatIdentMessage0710Controller(this);
        messageController.startReceivingMessages();

        //
        locationViolationException = model.getLocationViolation();
        sequenceViolationException = model.getSequenceViolationException();
        openExpirationViolation = model.getOpenExpirationViolation();

        System.out.println("locationViolationException\t" + locationViolationException.getRiskAssessment());
        System.out.println("sequenceViolationException\t" + sequenceViolationException.getRiskAssessment());
        System.out.println("openExpirationViolation\t" + openExpirationViolation.getRiskAssessment());

        sclKeyExceptionMap.put(KEY_LOCATION_VIOLATION_EXCEPTION, locationViolationException);
        sclKeyExceptionMap.put(KEY_SEQUENCE_VIOLATION_EXCEPTION, sequenceViolationException);
        sclKeyExceptionMap.put(KEY_OPEN_EXPIRATION_VIOLATION_EXCEPTION, openExpirationViolation);
    }

    private String getI18nError(String msgId) {
        return I18nMessageUtility.getLocalizedMessage(MSG_PACK, msgId);
    }


    private boolean isMandatoryPositionOpen() {
        if (model.getAutoConsume()) {
            // in case of auto consume no accounting is done and the position is completed in this phase at
            // phaseCompletion 勾选了自消耗，直接返回
            return false;
        }
        List<OrderStepInput> allMasterOSIs = model.getMasterOSIsForPhase();
        for(OrderStepInput masterOsi : allMasterOSIs) {
            if (isPlannedQtyModeNone(masterOsi)) {
                //没有选择物料计划模式
                continue;
            } else {
                //isPositionOpen=true, orderStepInput表示当前物料消耗数量未完成，需考虑其他替代物料的情况
                final boolean isPositionOpen = !getModel().isPositionCompleted(masterOsi);
                if (isPositionOpen) {
                    //检查
                    boolean replaceIsConsumed = checkReplaceIsConsumed(masterOsi, allMasterOSIs);
                    if (!replaceIsConsumed) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    private boolean checkReplaceIsConsumed(OrderStepInput masterOsi, List<OrderStepInput> allMasterOSIs) {
        //dustin-20220302
        List<IMESMaterialParameter> materialParameters = getPhase().getMaterialParameters();
        //materialParametersException = materialParameters;
        MeasuredValue totalConsumedQty = null;
        try {
            //返回消耗量
            totalConsumedQty = getSelfAndReplaceConsumedQty(masterOsi, allMasterOSIs, materialParameters);
        } catch (MESException e) {
            throw new MESRuntimeException(e);
        }

        //数量为null 代表没有物料被消耗 无法完成phase
        if (totalConsumedQty == null || totalConsumedQty.getValue().compareTo(BigDecimal.ZERO) == 0) {
            return false;
        }
        /**
         * 计划量 与实际消耗值做比较，实际主料的识别量不足 是否继续
         * tx
         * LC
         */
        List<IMESMaterialParameter> matParamList = materialParameters.stream().filter(p -> p.getMaterial() == masterOsi.getPart() && p.getATRow().getValue("LC_isMainPart") != null && (Boolean) p.getATRow().getValue("LC_isMainPart")).collect(Collectors.toList());
        if(matParamList.size() > 0){
            //当前物料是主料
            masterOsiException = null;
            totalConsumedQtyException = null;
            masterOsiException = masterOsi;
            totalConsumedQtyException = totalConsumedQty;
        }
//        MatIdentCompletionExceptions0710 exceptionsChecker = new MatIdentCompletionExceptions0710(this);
//        List<IMESMaterialParameter> matParamList = materialParameters.stream().filter(p -> p.getMaterial() == masterOsi.getPart() && p.getATRow().getValue("LC_isMainPart") != null && (Boolean) p.getATRow().getValue("LC_isMainPart")).collect(Collectors.toList());
//        if(matParamList.size()>0){
//            BigDecimal plannedQuantity = masterOsi.getPlannedQuantity().getValue();
//            if(plannedQuantity != null && plannedQuantity.compareTo(BigDecimal.ZERO) != 0){
//                if((totalConsumedQty.getValue()).compareTo(plannedQuantity) < 0){
//                    //主料实际识别量不足
//                    PhaseQuestionDialog questionDialog = new PhaseQuestionDialog();
//                    int torf = questionDialog.showDialog(MSG_PACK, "MainMatInsuffcientException", new Object[]{masterOsi.getPart().getPartNumber()});
//                    if(torf == 0){
//                        //点击的是 yes 跳转异常，可以完成phase。
//                        String msg = I18nMessageUtility.getLocalizedMessage(MSG_PACK, "MainMatInsuffcientExceptionMsg", new Object[]{masterOsi.getPart().getPartNumber()});
//                        if(showInputException(msg,KEY_MATERIAL_HYBRID_EXCEPTION)){
//                            return true;
//                        }else{
//                            return false;
//                        }
//                    }else {
//                        return false;
//                    }
//                }
//            }
//        }
        return true;
    }

    /**
     * dustin:获取主料及其对应的替代料数量
     *
     * @param osi
     * @param allMasterOSIs
     * @param materialParameters
     * @return
     */
    private static MeasuredValue getSelfAndReplaceConsumedQty(OrderStepInput osi, List<OrderStepInput> allMasterOSIs, List<IMESMaterialParameter> materialParameters) throws MESIncompatibleUoMException {
        //获取本身当前物料消耗数量
        MeasuredValue totalConsumedQtyMV = MESNamedUDAOrderStepInput.getTotalConsumedQuantity(osi);
        /**计算替代料数量**/
        //获取该物料是否设置为主料 为主料 有list
        List<IMESMaterialParameter> matParamList = materialParameters.stream().filter(p -> p.getMaterial() == osi.getPart() && p.getATRow().getValue("LC_isMainPart") != null && (Boolean) p.getATRow().getValue("LC_isMainPart")).collect(Collectors.toList());
        if (matParamList == null || matParamList.size() == 0) {
            //当前物料不为主料 返回当前物料的实际消耗数量
            return totalConsumedQtyMV;
        }

        MESNamedUDAMaterialParameter matParam = new MESNamedUDAMaterialParameter(matParamList.get(0));
        //获取主料 换算比例（替代比例）
        BigDecimal mainRatio = matParam.getReplaceRatio();
        //获取主料 替代组号
        String masterReplaceGroupName = matParam.getReplaceGroupName();
        //判断是否存在替代组号
        if (!StringUtils.isEmpty(masterReplaceGroupName)) {
            //获取替代物料集合(不能包含本身)
            Part material = matParam.getMatParam().getMaterial();
            List<IMESMaterialParameter> replaceGroupNameList = materialParameters.stream().filter(p -> {
                MESNamedUDAMaterialParameter replaceMatParam = new MESNamedUDAMaterialParameter(p);
                String replaceGroupName = replaceMatParam.getReplaceGroupName();
                Part replaceMaterial = p.getMaterial();
                return masterReplaceGroupName.equals(replaceGroupName) && !material.equals(replaceMaterial);
            }).collect(Collectors.toList());

            //替代 消耗量
            IMeasuredValueConverter converter = MeasuredValueUtilities.getMVConverter(osi.getPart());
            //获取主料计划数量单位
            IUnitOfMeasure unitOfMeasure = osi.getPlannedQuantity().getUnitOfMeasure();
            MeasuredValue replaceConsumedQtyMV = MeasuredValueUtilities.createZero(unitOfMeasure);
            //组合组号HashMap:组合组号-可消耗最小值
            Map<String, MeasuredValue> groupConsumedMap = new HashMap<>();
            //遍历替代料集合
            for (IMESMaterialParameter item : replaceGroupNameList) {
                MESNamedUDAMaterialParameter itemMatParam = new MESNamedUDAMaterialParameter(item);
                //获取计划量
                MeasuredValue plannedQuantityItem = itemMatParam.getMatParam().getPlannedQuantity();
                //获取替代比例
                BigDecimal replaceRatio = itemMatParam.getReplaceRatio();
                //获取组合组号
                String combinationGroup = itemMatParam.getCombinationGroup();
                //根据OSI获取替代消耗数量
                List<OrderStepInput> consumedList = allMasterOSIs.stream().filter(p -> p.getPart() == item.getMaterial()).collect(Collectors.toList());
                for (OrderStepInput replaceOSI : consumedList) {
                    //获取消耗量
                    MeasuredValue consumedQtyMV = MESNamedUDAOrderStepInput.getTotalConsumedQuantity(replaceOSI);
                    if (consumedQtyMV == null || replaceRatio == null) {
                        //消耗量为null || 替代比例为null   则存入“组合组号”：0 kg
                        groupConsumedMap.put(combinationGroup, MeasuredValueUtilities.createZero(unitOfMeasure));
                        continue;
                    }
                    //取出消耗量的值
                    BigDecimal consumedQty = consumedQtyMV.getValue();
                    //  计算总量 = 消耗量/替代比例*主料的替代比例
                    BigDecimal calcConsumedQty = consumedQty.divide(replaceRatio,4,BigDecimal.ROUND_HALF_UP).multiply(mainRatio);
                    MeasuredValue calcConsumedQtyMV = MeasuredValueUtilities.createMV(calcConsumedQty, consumedQtyMV.getUnitOfMeasure());

                    if (Strings.isEmpty(combinationGroup)) {
                        //组合组号为null，代表是独立物料替代
                        replaceConsumedQtyMV = MeasuredValueUtilities.addArgsOptional(replaceConsumedQtyMV, calcConsumedQtyMV, converter);
                    } else {
                        //组合组号不为null，代表是组合计算，以最小值计算
                        //获取组合组号，获取组号
                        MeasuredValue minConsumedQtyMV = groupConsumedMap.get(combinationGroup);
                        if (minConsumedQtyMV == null) {
                            //存入 组合组号：计算总量
                            groupConsumedMap.put(combinationGroup, calcConsumedQtyMV);
                            continue;
                        }
                        BigDecimal minConsumedQty = minConsumedQtyMV.getValue();
                        minConsumedQtyMV = calcConsumedQty.compareTo(minConsumedQty) < 0 ? calcConsumedQtyMV : minConsumedQtyMV;
                        groupConsumedMap.put(combinationGroup, minConsumedQtyMV);
                    }
                }
            }
            //增加组合组号数量
            if (groupConsumedMap != null) {
                for (MeasuredValue minConsumedQtyMV : groupConsumedMap.values()) {
                    replaceConsumedQtyMV = MeasuredValueUtilities.addArgsOptional(replaceConsumedQtyMV, minConsumedQtyMV, converter);
                }
            }
            //替代物料数量 + 主料本身数量
            if (totalConsumedQtyMV != null) {
                replaceConsumedQtyMV = MeasuredValueUtilities.addArgsOptional(totalConsumedQtyMV, replaceConsumedQtyMV, converter);
            }
            totalConsumedQtyMV = replaceConsumedQtyMV;
        }
        return totalConsumedQtyMV;
    }

    /*
    是否没有设置计划模式
     */
    private boolean isPlannedQtyModeNone(OrderStepInput masterOsi) {
        return PlannedQuantityMode.NONE.equals(model.getPlannedQuantityMode(masterOsi));
    }

    private boolean consumeSublots() {
        if (!model.getAutoConsume()) {
            return true;
        }
        WarehouseRuntimeException lastWHException = null;
        List<OrderStepInput> osisOfSublotsToConsume = model.getOSIsOfSublotsToConsume();

        try (OSILockCollection osiLockCollection = new OSILockCollection(osisOfSublotsToConsume, getRtPhase())) {
            if (osiLockCollection.isOwnerChange()) {
                model.getOrderStep(true);
            }
            for (OrderStepInput osi : osisOfSublotsToConsume) {
                lastWHException = consumeSublot(osi);
            }
        } catch (OSILock.LockException e) {
            throw new MESRuntimeException(e);
        }

        if (lastWHException != null) {
            model.setLastWarehouseExceptionAndError(lastWHException, CONSUME_SUBLOT_WAREHOUSE_ERROR_MSG_ID);
            ProductPhaseSwingHelper.showErrorDlg(model.createWarehouseErrorMessage(MSG_PACK, null, true));
            return false;
        }

        model.resetLastWarehouseExceptionAndError();
        return true;
    }

    private WarehouseRuntimeException consumeSublot(OrderStepInput osi) {

        WarehouseRuntimeException lastWHException = null;
        final Sublot attachSublot = osi.getAttachSublot();
        final MeasuredValue quantity = attachSublot.getQuantity();
        try {
            final IOrderStepExecutionService osExecSrv = MaterialHelper0710.getOrderStepExecutionService();
            osExecSrv.consumeSublotAttachedToOrderStepInput(osi, quantity, getModel().getConsumptionOptions(osi), StringUtilsEx.EMPTY);
        } catch (MESIncompatibleUoMException | MESQuantityMustNotBeNegativeException |
                 MESSublotOperationNotAllowedException e) {
            throw new MESRuntimeException(e);
        } catch (WarehouseRuntimeException e) {
            lastWHException = e;
        }

        try {
            final ISublotService sublotService = ServiceFactory.getService(ISublotService.class);
            deleteSublotLogically(sublotService, osi, attachSublot);
        } catch (MESQuantityExceedsAllowedVariationException e) {
            throw new MESRuntimeException(e);
        } catch (WarehouseRuntimeException e) {
            lastWHException = e;
        }

        return lastWHException;
    }

    private void deleteSublotLogically(ISublotService sublotService, OrderStepInput osi, Sublot attachSublot) throws MESQuantityExceedsAllowedVariationException {
        TransactionHistoryContext transactionHistoryContext = MaterialHelper0710.getMESOrderService().configureTransactionHistoryContext(null, osi.getOrderStep());
        transactionHistoryContext.setTransactionHistorySubtype(TransactionSubtype.CONSUMPTION_INPUT_MATERIAL);
        transactionHistoryContext.setRemark(StringUtilsEx.EMPTY);
        sublotService.deleteSublotLogically(attachSublot, transactionHistoryContext);
    }

    /**
     * 实际执行根据子批次条码获取子批次对象
     *
     * @param barcode
     * @return Sublot 子批次
     * @throws MESInvalidBarcodeException
     */
    private Sublot getSublotByBarcode(String barcode) throws MESInvalidBarcodeException {
        IMFCService mfcService = ServiceFactory.getService(IMFCService.class);
        return mfcService.getSublotFromBarcode(barcode);
    }

    private Sublot getSublotByIdentifier(String sublotID) throws MESException {
        SublotFilter sublotFilter = PCContext.getFunctions().createSublotFilter();
        sublotFilter = sublotFilter.forNameEqualTo(sublotID);
        List<Sublot> filteredSublots = PCContext.getFunctions().getFilteredSublots(sublotFilter);
        if (filteredSublots != null && filteredSublots.size() == 1) {
            return filteredSublots.get(0);
        } else if (filteredSublots != null && filteredSublots.size() > 1) {
            throw new MESException(I18nMessageUtility.getLocalizedMessage(MSG_PACK, "NotUniqueSublotTxt", new Object[]{sublotID}));
        } else {
            throw new MESException(I18nMessageUtility.getLocalizedMessage(MSG_PACK, "SublotNotExistTxt", new Object[]{sublotID}));
        }
    }


    private String getLogisticUnitByBarcode(String barcode) throws MESException {
        boolean doesExists = false;
        Pair<String, String> luData = null;
        try {
            luData = WAREHOUSE_SERVICE.getLogisticUnit(StringUtils.EMPTY, barcode);
            if (luData != null) {
                doesExists = true;
            }
        } catch (WarehouseRuntimeException e) {
            LOGGER.error("Warehouse error occurred while retrieving logistic unit by barcode", e);
            doesExists = false;
        }
        if (doesExists) {
            return luData.getFirst();
        } else {
            throw new MESException(I18nMessageUtility.getLocalizedMessage(MSG_PACK, "LUNotExistTxt", new Object[]{barcode}));
        }
    }

    private String getLogisticUnitByIdentifier(String logisticUnitId) throws MESException {
        boolean doesExists = false;
        Pair<String, String> luData = null;
        try {
            luData = WAREHOUSE_SERVICE.getLogisticUnit(logisticUnitId, StringUtils.EMPTY);
            if (luData != null) {
                doesExists = true;
            }
        } catch (WarehouseRuntimeException e) {
            LOGGER.error("Warehouse error occurred while retrieving logistic unit by identifier", e);
            doesExists = false;
        }
        if (doesExists) {
            return luData.getFirst();
        } else {
            throw new MESException(I18nMessageUtility.getLocalizedMessage(MSG_PACK, "LUNotExistTxt", new Object[]{logisticUnitId}));
        }
    }

    /**
     * 根据子批次条码获取子批次对象构造 IIdentifiedItem0710
     *
     * @param barcode 子批次条码
     * @return IIdentifiedItem0710
     * @throws MESException
     */
    private IIdentifiedItem0710 getIdentifiedItemByBarcode(String barcode) throws MESException {
        IIdentifiedItem0710 item = null;
        Sublot sublot = null;
        MESException invalidBarcodeException = null;
        try {
            sublot = getSublotByBarcode(barcode);
        } catch (MESInvalidBarcodeException exc) {
            invalidBarcodeException = exc;
            LOGGER.debug("Fetching sublot from barcode failed.", exc);
        }

        if (sublot != null) {
            item = IdentifiedItem0710.createItem(sublot);
        } else if (model.isWarehauseApplicationAvailable()) {
            try {
                final String logisticUnit = getLogisticUnitByBarcode(barcode);
                if (logisticUnit != null) {
                    item = IdentifiedItem0710.createItem(logisticUnit);
                }
            } catch (MESException exc) {
                invalidBarcodeException = exc;
                LOGGER.debug("Fetching logistic unit from barcode failed.", exc);
            }
        }
        if (item == null) {
            if (invalidBarcodeException != null) {
                throw invalidBarcodeException;
            } else {
                // this should never happen, if the item is null, the invalidBarcodeException should be initialized
                // if this is thrown, the business logic changed
                throw new MESRuntimeException("Could not load anything based on barcode " + barcode);
            }
        }

        if (item.isLogisticUnit() && item.getSublotsOfLogisticUnit().isEmpty()) {
            throw new MESException(I18nMessageUtility.getLocalizedMessage(MSG_PACK, "LUIdentNoSublotsTxt", new Object[]{item.getName()}));
        }
        //开启过参
        boolean batchExclusiveUse = model.getBatchExclusiveUse();
        if (batchExclusiveUse) {
            try {
                Object sapOrderNumberObj = sublot.getUDA("SV_orderNumber");
                String sapOrderNumber = sapOrderNumberObj != null ? sapOrderNumberObj.toString() : "";
                ProcessOrderItem processOrderItem = getOrderStep().getControlRecipe().getProcessOrderItem();
                String orderNo = processOrderItem.getOrderName();
                if (!sapOrderNumber.equals("000" + orderNo) && !sapOrderNumber.equals(orderNo)) {
                    throw new MESException(I18nMessageUtility.getLocalizedMessage(MSG_PACK, "IdentSublotIsNotInOrderTxt", new Object[]{item.getName()}));
                }
            } catch (DatasweepException e) {
                throw new RuntimeException(e);
            }
        }
        return item;
    }

    private IIdentifiedItem0710 getIdentifiedItemByIdentifier(String itemId) throws MESException {
        IIdentifiedItem0710 item = null;
        Sublot sublot = null;
        String localizedMessage = StringUtilsEx.EMPTY;
        try {
            sublot = getSublotByIdentifier(itemId);
        } catch (MESException exc) {
            localizedMessage = exc.getLocalizedMessage();
            LOGGER.debug("Fetching sublot from identifier failed.", exc);
        }

        if (sublot != null) {
            item = IdentifiedItem0710.createItem(sublot);
        } else if (model.isWarehauseApplicationAvailable()) {
            try {
                String logisticUnit = getLogisticUnitByIdentifier(itemId);
                if (logisticUnit != null) {
                    item = IdentifiedItem0710.createItem(logisticUnit);
                }
            } catch (MESException e) {
                localizedMessage = StringUtilsEx.EMPTY.equals(localizedMessage) ? e.getLocalizedMessage() : localizedMessage + StringConstants.LINE_BREAK + e.getLocalizedMessage();
                LOGGER.debug("Fetching logistic unit from identifier failed.", e);
            }
        }
        if (item == null) {
            throw new MESException(localizedMessage);
        }
        if (item.isLogisticUnit() && item.getSublotsOfLogisticUnit().isEmpty()) {
            throw new MESException(I18nMessageUtility.getLocalizedMessage(MSG_PACK, "LUIdentNoSublotsTxt", new Object[]{item.getName()}));
        }

        return item;
    }

    /**
     * Create list of disabled identification checks for this sublot
     *
     * @param sublot scanned sublot
     * @return list of disabled identification checks for this sublot
     */
    private List<String> getDisabledChecks(Sublot sublot) {
        Map<String, Object> allocatedBatches = getAllocatedBatches(sublot.getPart().getPartNumber());
        List<String> disabledChecks = new ArrayList<>();
        if (allocatedBatches.size() == 0) {
            disabledChecks.add(ParamClassConstants0400.PARAMETER_ALLOCATION);
        }
        return disabledChecks;
    }

    /**
     * @param signatureExecutor
     * @param isAction
     * @return
     * @throws MESException
     * @throws DatasweepException
     */
    private IPhaseIdentificationCheckSuite0710 performIdentification(final IESignatureExecutor signatureExecutor, final boolean isAction) throws MESException, DatasweepException {
        model.getOrderStep(true);
        if (signatureExecutor == null) {
            identCheckSuite.clearCheckSuites();
            sclCheckExceptionMessage.clear();
        }

        final Pair<List<IdentificationSublot>, Map<Sublot, OrderStepInput>> identificationData = getSublotsToIdentify(signatureExecutor, isAction);
        final List<IdentificationSublot> sublotsToIdentify = identificationData.getFirst();
        final Map<Sublot, OrderStepInput> sublotOSIMap = identificationData.getSecond();
        Collection<OrderStepInput> oSIsTOLock = new HashSet<>(sublotOSIMap.values());


//        /**
//         * Yonghao Xu
//         *
//         * SCL
//         */
//        SCLDefaultExecuteCheckParameter executeCheckParameter = new SCLDefaultExecuteCheckParameter();
//        executeCheckParameter.setWorkCenter(PCContext.getFunctions().getStation().getWorkCenter());
//        List<Sublot> sublotList = sublotsToIdentify.stream().map(IdentificationSublot::getSublot).collect(Collectors.toList());
//        executeCheckParameter.setSublotList(sublotList);
//        executeCheckParameter.setSublot(sublotList.get(0));
//        executeCheckParameter.setOrderStep(getOrderStep());
//        IdentificationSublot identificationSublot = sublotsToIdentify.get(0);
//        if (locationViolationException != null && locationViolationException.getEnabled() != null && locationViolationException.getEnabled()) {
//            LocationChecker checker = new LocationChecker();
//            Boolean checkResult = checker.executeCheck(executeCheckParameter);
//
//            if (checkResult == false) {
////                displayException(KEY_LOCATION_VIOLATION_EXCEPTION,
////                        IMESExceptionRecord.RiskClass.valueOf(locationViolationException.getRiskAssessment()),
////                        locationViolationException.getMessage()+
////                        StringUtils.join(checker.getErrorList(),",")
////                        );
//                identificationSublot.getCheckSuite().getExceptionList().addAll(checker.getExceptionList());
//                sclCheckExceptionMessage.put(KEY_LOCATION_VIOLATION_EXCEPTION, new ArrayList<String>() {
//                    {
//                        addAll(checker.getExceptionList());
//
//                    }
//                });
//
//            }
//        }
//
//        if (openExpirationViolation != null && openExpirationViolation.getEnabled() != null && openExpirationViolation.getEnabled()) {
//            OpenExpirationChecker checker = new OpenExpirationChecker();
//            Boolean checkResult = checker.executeCheck(executeCheckParameter);
//            if (checkResult == false) {
////                displayException(KEY_OPEN_EXPIRATION_VIOLATION_EXCEPTION,
////                        IMESExceptionRecord.RiskClass.valueOf(openExpirationViolation.getRiskAssessment()),
////                        openExpirationViolation.getMessage()+
////                                StringUtils.join(checker.getErrorList(),",")
////                );
//                identificationSublot.getCheckSuite().getExceptionList().addAll(checker.getExceptionList());
//                sclCheckExceptionMessage.put(KEY_OPEN_EXPIRATION_VIOLATION_EXCEPTION, new ArrayList<String>() {
//                    {
//                        addAll(checker.getExceptionList());
//                    }
//                });
//            }
//
//        }
//
//        if (sequenceViolationException != null && sequenceViolationException.getEnabled() != null && sequenceViolationException.getEnabled()) {
//            String sequenceRule = model.getSequenceRule();
//            if (StringUtils.isNotEmpty(sequenceRule)) {
//                executeCheckParameter.setSequenceRule(sequenceRule);
//
//                SequenceRuleChecker checker = new SequenceRuleChecker();
//                Boolean checkResult = checker.executeCheck(executeCheckParameter);
//                if (checkResult == false) {
////                    displayException(KEY_SEQUENCE_VIOLATION_EXCEPTION,
////                            IMESExceptionRecord.RiskClass.valueOf(sequenceViolationException.getRiskAssessment()),
////                            sequenceViolationException.getMessage()+
////                                    StringUtils.join(checker.getErrorList(),",")
////                    );
//                    identificationSublot.getCheckSuite().getExceptionList().addAll(checker.getExceptionList());
//                    sclCheckExceptionMessage.put(KEY_SEQUENCE_VIOLATION_EXCEPTION, new ArrayList<String>() {
//                        {
//                            addAll(checker.getExceptionList());
//                        }
//                    });
//                }
//            }
//
//
//        }
//
//        if (model.getBatchExclusiveUse()) {
//            // 此处只校验
//            BatchExclusiveUseChecker checker = new BatchExclusiveUseChecker();
//            Boolean checkResult = checker.executeCheck(executeCheckParameter);
//        }
        /**
         * Yonghao Xu
         *
         * SCL
         */
        if (MapUtils.isNotEmpty(sclCheckExceptionMessage) && signatureExecutor == null) {
            /**
             * SCL
             * 2021年12月27日23:47:22
             * 修复只有SCL异常（没有非标异常情况下）子批次被错误识别并绑定
             * 导致异常签名之后无法识别切无法进行的bug
             * Yonghao Xu
             */
        } else {
            // lock OSIs resp. the corresponding material position to avoid simultaneously changes on osi e.g of the Account
            // Phase
            try (OSILockCollection lockCollection = new OSILockCollection(oSIsTOLock, getRtPhase())) {
                if (lockCollection.isOwnerChange()) {
                    model.getOrderStep(true);
                }
                Map<Sublot, IdentificationResult> identificationRes = identifySublotsForOSIs(sublotsToIdentify);

                System.out.println("Error_Msg"+identCheckSuite.getCollectedErrorMessage());
                postIdentificationProcessing(isAction, sublotOSIMap, identificationRes);
            } catch (OSILock.LockException e) {
                throw new MESRuntimeException(e);
            }
        }
        return identCheckSuite;
    }

    private Map<Sublot, IdentificationResult> identifySublotsForOSIs(final List<IdentificationSublot> sublotsToIdentify) throws MESException, DatasweepException {
        Map<Sublot, IdentificationResult> identificationRes = null;
        try {
            final IOrderStepExecutionService osExecSrv = MaterialHelper0710.getOrderStepExecutionService();

            identificationRes = osExecSrv.identifySublotsForOSIsAndSplitIfNecessary(sublotsToIdentify);
        } catch (MESMultipleSublotsIdentificationException exc) {
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug(exc.getMessage());
            }
            identificationRes = exc.getIdentificationResultMap();
            model.getOrderStep(true);
            for (final Map.Entry<Sublot, IdentificationResult> resultEntry : identificationRes.entrySet()) {
                final Sublot sublot = resultEntry.getKey();
                sublot.refresh();
            }
        }
        return identificationRes;
    }

    /**
     * 只在identificationRes 结果是OK的情况下执行
     *
     * @param isAction
     * @param sublotOSIMap
     * @param identificationRes
     */
    private void postIdentificationProcessing(final boolean isAction, final Map<Sublot, OrderStepInput> sublotOSIMap, Map<Sublot, IdentificationResult> identificationRes) {
        if (isIdentificationResultOK(identificationRes.values())) {
            boolean addSublot = true;
            model.getOrderStep(addSublot);
            final String logisticUnitId = identifiedItem.isLogisticUnit() ? identifiedItem.getLogisticUnit() : null;
            for (final Map.Entry<Sublot, IdentificationResult> resultEntry : identificationRes.entrySet()) {
                final Sublot sublot = resultEntry.getKey();
                final OrderStepInput osi = sublotOSIMap.get(sublot);
                String mfcPos = MESNamedUDAOrderStepInput.getPosition(osi);
                updateReportData(sublot.getPart().getPartNumber(), mfcPos, String.valueOf(osi.getKey()), Collections.singletonList(sublot), logisticUnitId, addSublot, false);
                updateAllocatedSublotsOnHeaderMaterialAndPhaseData(osi);
                if (isAction) {
                    consumeSublotOnAction(resultEntry.getValue().getOrderStepInputSublot());
                }
            }
            saveRtPhase();
            model.setIdentificationDone(addSublot);

            // update material list according changes of identification
            model.refreshMaterialsList();
        }
    }

    private void updateAllocatedSublotsOnHeaderMaterialAndPhaseData(OrderStepInput masterOsi) {

        for (IdentifiedMaterialDAO0710 material : model.getMatInputList()) {
            if (material.getOsiKey() == masterOsi.getKey()) {
                model.initAllocBatchesSublotOnMaterial(material);
                updateHeaderPhaseData();
                return;
            }
        }
    }

    private Pair<List<IdentificationSublot>, Map<Sublot, OrderStepInput>> getSublotsToIdentify(final IESignatureExecutor signatureExecutor, boolean isAction) throws MESException, DatasweepException {
        final IOrderStepExecutionService osExecSrv = MaterialHelper0710.getOrderStepExecutionService();
        final List<IdentificationSublot> sublotsToIdentify = new ArrayList<>();
        //if (null != identifiedItem){
            final List<Sublot> sublots = identifiedItem.getSublots();
            final Map<Sublot, OrderStepInput> sublotOSIMap = new HashMap<>();

            for (Sublot sublot : sublots) {
                final OrderStepInput osi = getRelatedOSI(sublot, isAction);
                IIdentificationCheckSuite checkSuite;
                List<IESignatureExecutor> signatures = null;
                List<String> signedExceptions = new ArrayList<>();
                if (signatureExecutor != null) {
                    sublot.refresh();
                    checkSuite = identCheckSuite.getCheckSuite(sublot);
                    signatures = setupSignatureExecutor(signatureExecutor, signedExceptions, checkSuite);
                } else {
                    checkSuite = identCheckSuite.createCheckSuite(sublot, getDisabledChecks(sublot));
                }
                final IdentificationSublot identificationSublot = //
                        osExecSrv.createIdentificationSublotData(sublot, null, osExecSrv.getOrderStepInputPosition(osi), signatures, null, checkSuite, signedExceptions);
                sublotsToIdentify.add(identificationSublot);
                sublotOSIMap.put(sublot, osi);
            }
            return new Pair(sublotsToIdentify, sublotOSIMap);
//        }
//        return new Pair(sublotsToIdentify, null);
    }

    private boolean isIdentificationResultOK(final Collection<IdentificationResult> identificationResults) {
        boolean isOK = true;
        for (final IdentificationResult result : identificationResults) {
            if (!result.getIdentificationCheckSuite().isOk()) {
                isOK = false;
                break;
            }
        }
        return isOK;
    }

    private void checkForUndo() throws MESIncompatibleUoMException, RtPhaseExecutorMatAlterIdent0010.UndoCheckFailedException {
        if (identifiedItem.isSublot()) {
            checkForUndoForSublot();
        } else {
            checkForUndoForLogisticUnit();
        }
    }

    /**
     * A specific exception thrown when one of the checks performed on undo ident fails; the exception contains the
     * localized error
     * <p>
     *
     * @author ikoleva, (c) Copyright 2020 Rockwell Automation Technologies, Inc. All Rights Reserved.
     */
    private static class UndoCheckFailedException extends MESException {
        private static final long serialVersionUID = 1L;

        private final String detailedMessage;

        private UndoCheckFailedException(String aMessagePackName, String aMessageID, Object[] messArgs, //
                                         String unlocalizedDetailMessage) {
            super(aMessagePackName, aMessageID, messArgs, unlocalizedDetailMessage);
            detailedMessage = unlocalizedDetailMessage;
        }

        /**
         * @return additional detailed message; could be null
         */
        public String getDetailedMessage() {
            return detailedMessage;
        }
    }

    /**
     * Check if a sublot is valid for undo identification.
     *
     * @return the result of the check: <code>true</code> if undo is allowed, otherwise <code>false</code>
     * @throws MESIncompatibleUoMException when quantities have incompatible units of measure
     */
    private void checkForUndoForSublot() throws MESIncompatibleUoMException, RtPhaseExecutorMatAlterIdent0010.UndoCheckFailedException {
        Sublot sublot = identifiedItem.getSublot();
        model.getOrderStep(true);
        IOrderStepExecutionService osExecSrv = MaterialHelper0710.getOrderStepExecutionService();
        boolean isConsumedOSIFound = false;
        // get the master order step inputs for the material of the sublot
        for (final OrderStepInput osi : model.getMasterOSIsOfMaterial().get(sublot.getPart().getPartNumber())) {
            for (final OrderStepInputSublot osiSublot : osExecSrv.getIdentifiedOSISublots(osi, false, false)) {
                // if a sublot is released and no quantity was consumed:
                // it was unidentified
                if (!osiSublot.getSublot().getUniqueName().equals(sublot.getUniqueName()) || (osiSublot.isReleased() && osiSublot.getConsumedQuantity() == null)) {
                    continue;
                }
                if (osiSublot.isReleased() || osiSublot.getAccountedQuantity() != null) {
                    // if a sublot is released and quantity was
                    // consumed: it was consumed,
                    // cannot be unidentified
                    isConsumedOSIFound = true;
                } else {
                    // the sublot is identified for this order step:
                    // undo can be performed
                    identifiedItem.setMasterOSIs(Collections.singletonList(osi));
                    return;
                }
            }
        }

        String errMsgID = isConsumedOSIFound ? "SublotsConsumedTxt" : "SublotNotFound";
        throw new RtPhaseExecutorMatAlterIdent0010.UndoCheckFailedException(MSG_PACK, errMsgID, new Object[]{sublot.getUniqueName()}, null);
    }

    private void checkForUndoForLogisticUnit() throws MESIncompatibleUoMException, RtPhaseExecutorMatAlterIdent0010.UndoCheckFailedException {
        sublotNamesForUndoLUIdentifucation.clear();
        sublotsForUndoLUIdentification.clear();
        final List<String> sublotNamesForUndo = getSublotNamesForUndo(identifiedItem.getLogisticUnit());
        if (sublotNamesForUndo.isEmpty()) {
            throw new RtPhaseExecutorMatAlterIdent0010.UndoCheckFailedException(MSG_PACK, "LUUndoIdentNoSublotsTxt", new Object[]{identifiedItem.getName()}, null);
        }
        model.getOrderStep(true);
        final IOrderStepExecutionService osExecSrv = MaterialHelper0710.getOrderStepExecutionService();
        final List<String> consumedSublots = new ArrayList<>();
        final List<String> identifiedSublots = new ArrayList<>();
        final List<Sublot> identifiedSublotObjects = new ArrayList<>();
        final List<OrderStepInput> masterOSIs = new ArrayList();

        // get the sublots identified for the order step inputs
        for (final OrderStepInput osi : model.getMasterOSIsForPhase()) {
            // work only with the original osi
            for (final OrderStepInputSublot osiSublot : osExecSrv.getIdentifiedOSISublots(osi, false, false)) {
                // if a sublot is released and no quantity was consumed: it was unidentified
                if ((osiSublot.isReleased() && osiSublot.getConsumedQuantity() == null) || !sublotNamesForUndo.contains(osiSublot.getSublot().getUniqueName())) {
                    continue;
                }
                if (osiSublot.isReleased() || osiSublot.getAccountedQuantity() != null) {
                    // if a sublot is released and quantity was
                    // consumed: it was consumed,
                    // cannot be unidentified
                    consumedSublots.add(osiSublot.getSublot().getUniqueName());
                } else {
                    // the sublot is identified for this order step:
                    // undo can be performed for it
                    identifiedSublots.add(osiSublot.getSublot().getUniqueName());
                    identifiedSublotObjects.add(osiSublot.getSublot());
                    masterOSIs.add(osi);
                }
            }
        }

        // evaluate the result:
        evaluateCheckForUndoResult(sublotNamesForUndo, consumedSublots, identifiedSublots);
        // remember the sublots that can be unidentified
        sublotNamesForUndoLUIdentifucation.addAll(identifiedSublots);
        sublotsForUndoLUIdentification.addAll(identifiedSublotObjects);
        identifiedItem.setMasterOSIs(masterOSIs);

    }

    private List<String> getSublotNamesForUndo(final String logisticUnitId) {
        final List<String> sublotsForUndo = new ArrayList<>();
        final List<MESRtPhaseDataMatAlterIdent0010> allRtPhaseData = model.getAllRtPhaseData();
        for (MESRtPhaseDataMatAlterIdent0010 data : allRtPhaseData) {
            if (!data.getIsHeader() && !data.getIsUnidentified() && logisticUnitId.equals(data.getLogisticUnitID())) {
                sublotsForUndo.add(data.getSublotIDStr());
            }
        }
        return sublotsForUndo;
    }

    private List<Sublot> getSublotsForUndo() {
        if (identifiedItem.isSublot()) {
            return Collections.singletonList(identifiedItem.getSublot());
        }
        return sublotsForUndoLUIdentification;
    }

    private void evaluateCheckForUndoResult(final List<String> sublotNamesForUndo, final List<String> consumedSublots, final List<String> identifiedSublots) throws RtPhaseExecutorMatAlterIdent0010.UndoCheckFailedException {
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("CheckForUndo result evaluation for logistic unit " + identifiedItem.getName());
            LOGGER.debug("-- sublotNamesForUndo: " + StringUtilsEx.buildSeparatedListForUI(sublotNamesForUndo, Integer.MAX_VALUE, MatIdentModel0710.MATERIAL_ID_DELIMITER_IN_DATA));
            LOGGER.debug("-- consumedSublots: " + StringUtilsEx.buildSeparatedListForUI(consumedSublots, Integer.MAX_VALUE, MatIdentModel0710.MATERIAL_ID_DELIMITER_IN_DATA));
            LOGGER.debug("-- identifiedSublots: " + StringUtilsEx.buildSeparatedListForUI(identifiedSublots, Integer.MAX_VALUE, MatIdentModel0710.MATERIAL_ID_DELIMITER_IN_DATA));
        }

        if (sublotNamesForUndo.size() == consumedSublots.size()) {
            // all sublots on the logistic unit are already consumed
            throw new RtPhaseExecutorMatAlterIdent0010.UndoCheckFailedException(MSG_PACK, "LUUndoIdentAllSublotsConsumedTxt", new Object[]{identifiedItem.getName()}, null);
        }

        if (sublotNamesForUndo.size() > identifiedSublots.size() + consumedSublots.size()) {
            // there are sublots that are not found in the already identified or consumed
            sublotNamesForUndo.removeAll(identifiedSublots);
            sublotNamesForUndo.removeAll(consumedSublots);
            final String detailMessage = I18nMessageUtility.getLocalizedMessage(MSG_PACK, "LUUndoIdentNotIdentifiedDetailsTxt")//
                    + StringConstants.LINE_BREAK //
                    + StringUtilsEx.buildSeparatedListForUI(sublotNamesForUndo, Integer.MAX_VALUE, StringConstants.LINE_BREAK);
            throw new RtPhaseExecutorMatAlterIdent0010.UndoCheckFailedException(MSG_PACK, "LUUndoIdentSublotsNotIdentifiedTxt", new Object[]{identifiedItem.getName()}, detailMessage);
        }
    }

    private IPhaseIdentificationCheckSuite0710 executePreChecks(boolean onPostAction) throws MESException {
        identCheckSuite.clearCheckSuites();
        sclCheckExceptionMessage.clear();
        final List<Sublot> sublots = identifiedItem.getSublots();
        for (final Sublot sublot : sublots) {
            final OrderStepInput osi = getRelatedOSI(sublot, onPostAction);
            final IIdentificationCheckSuite checkSuite = identCheckSuite.createCheckSuite(sublot, getDisabledChecks(sublot));
            checkSuite.executeCheck(new ExecuteCheckParameter(sublot, osi));
        }
        return identCheckSuite;
    }

    private void undoIdent() {
        List<OrderStepInput> masterOSIs = identifiedItem.getMasterOSIs();
        try (OSILockCollection lock = new OSILockCollection(masterOSIs, getRtPhase())) {
            if (lock.isOwnerChange()) {
                model.getOrderStep(true);
            }
            checkForUndo();

            final String logisticUnitId = identifiedItem.isLogisticUnit() ? identifiedItem.getLogisticUnit() : null;
            final List<Sublot> sublotsForUndoIdent = getSublotsForUndo();

            for (final Sublot sublotForUndoIdent : sublotsForUndoIdent) {
                List<OrderStepInput> osiList = model.getOsiMap().get(sublotForUndoIdent.getPart().getPartNumber());
                if (osiList != null) {
                    OrderStepInput osi = releaseIdentificationOfSublot(sublotForUndoIdent, osiList);
                    OrderStepInput masterOSI = getUnsplittedOSI(osi);
                    ServiceFactory.getService(IOrderStepExecutionService.class).updateTotalIdentifiedQtyAndNumSublots(masterOSI, sublotForUndoIdent, false);
                    String osiNumber = (masterOSI != null) ? String.valueOf(masterOSI.getKey()) : StringUtilsEx.EMPTY;
                    String mfcPos = (osi != null) ? MESNamedUDAOrderStepInput.getPosition(osi) : StringUtilsEx.EMPTY;
                    updateReportData(sublotForUndoIdent.getPart().getPartNumber(), mfcPos, osiNumber, Collections.singletonList(sublotForUndoIdent), logisticUnitId, false, false);
                    updateAllocatedSublotsOnHeaderMaterialAndPhaseData(masterOSI);
                    model.setIdentificationDone(false);
                }
            }
            // save the OS at the end to apply the changes performed by updateTotalIdentifiedQtyAndNumSublots
            model.getOrderStep(false).Save(null, "", PCContext.getDefaultAccessPrivilege());
        } catch (OSILock.LockException | MESIncompatibleUoMException | DatasweepException exc) {
            throw new MESRuntimeException(exc);
        } catch (RtPhaseExecutorMatAlterIdent0010.UndoCheckFailedException e) {
            // do not show the error as a dialog because we are in a user transaction: throw a runtime exception instead
            String err = e.getLocalizedMessage();
            if (StringUtils.isNotEmpty(e.getDetailedMessage())) {
                err += StringConstants.NEW_LINE + e.getDetailedMessage();
            }
            throw new MESRuntimeException(err, e);
        }
        saveRtPhase();
        model.refreshMaterialsList();
    }


    private OrderStepInput releaseIdentificationOfSublot(final Sublot sublotForUndoIdent, List<OrderStepInput> osiList) {
        final IMFCService mfcService = ServiceFactory.getService(IMFCService.class);
        for (OrderStepInput osii : osiList) {
            final Long identifiedForOSIKey = MESNamedUDASublot.getIdentifiedForOSI(sublotForUndoIdent);
            // if a sublot is identified, undo identified and again identified the identifiedForOSIKey shows the
            // effective OSI. getAttachSublot() returns also on the first osi the sublot although it has been
            // unidentified.
            if (osii.getAttachSublot() != null //
                    && osii.getAttachSublot().getUniqueName().equals(sublotForUndoIdent.getUniqueName()) //
                    && identifiedForOSIKey != null && identifiedForOSIKey.longValue() == osii.getKey()) {
                mfcService.releaseIdentification(sublotForUndoIdent, osii);
                return osii;
            }
        }
        return null;
    }

    /**
     * Find an unsplit OSI corresponding to the sublot
     *
     * @param sublot       the identified sublot
     * @param onPostAction called by a post completion action
     * @return the unsplit OSI
     * @throws MESException if no unique OSI can be selected for this sublot
     */
    private OrderStepInput getRelatedOSI(Sublot sublot, boolean onPostAction) throws MESException {
        List<OrderStepInput> osiList = findAllMatchingOSIs(sublot, onPostAction);
        if (osiList.size() == 1) {
            return osiList.get(0);
        } else if (osiList.size() > 1) {
            List<OrderStepInput> osiListNoTransfer = new ArrayList<>();
            for (MatIdentModel0710.MasterOSIWithBatchAllocations osiBatchEntry : model.getMasterOSIsWithBatchAllocations().get(sublot.getPart().getPartNumber())) {
                OrderStepInput osi = osiBatchEntry.getOsi();
                // Search for OSIs which has the sublot's batch allocated
                if (osi.getProcessingType() != OrderStepInput.INPUT_TYPE_INTERMEDIATE) {
                    osiListNoTransfer.add(osi);
                }
            }
            if (osiListNoTransfer.size() == 1) {
                return osiListNoTransfer.get(0);
            }
            throw new MESException(I18nMessageUtility.getLocalizedMessage(MSG_PACK, "CannotIdentifySublotBOMPosition", new Object[]{sublot.getUniqueName()}));
        }
        throw new MESException(I18nMessageUtility.getLocalizedMessage(MSG_PACK, "CannotIdentifySublotMaterial"));
    }

    private List<OrderStepInput> findAllMatchingOSIs(Sublot sublot, boolean onPostAction) {
        List<OrderStepInput> osiList = new ArrayList<>();
        List<MatIdentModel0710.MasterOSIWithBatchAllocations> osisForSublotMaterial = model.getMasterOSIsWithBatchAllocations().get(sublot.getPart().getPartNumber());
        if (osisForSublotMaterial == null) {
            return Collections.emptyList();
        }
        // on post completion actions identification is not limited to open positions
        List<MatIdentModel0710.MasterOSIWithBatchAllocations> relevantOSIPostions = onPostAction ? osisForSublotMaterial : osisForSublotMaterial.stream().filter(val -> !isNotNonePositionCompleted(val.getOsi())).collect(Collectors.toList());

        for (MatIdentModel0710.MasterOSIWithBatchAllocations osiBatchEntry : relevantOSIPostions) {
            OrderStepInput currOsi = osiBatchEntry.getOsi();
            if (osiBatchEntry.getAllocatedBatches().contains(sublot.getBatch())) {
                if (currOsi.getProcessingType() == OrderStepInput.INPUT_TYPE_INTERMEDIATE) {
                    IOrderStepExecutionService service = MaterialHelper0710.getOrderStepExecutionService();
                    if (service.getAllocatedSublots(currOsi).stream().anyMatch(as -> as.getSublot().equals(sublot))) {
                        return Collections.singletonList(currOsi);
                    }
                }
                osiList.add(currOsi);
            }
        }
        if (osiList.isEmpty()) {
            // Search for OSIs which has no batch allocated
            relevantOSIPostions.stream().filter(val -> val.getAllocatedBatches().isEmpty()).forEach(val -> osiList.add(val.getOsi()));
        }
        if (osiList.isEmpty()) {
            // Search for OSIs with with the same material but allocated other batches
            // if the allocation check is enabled, the OSI can be used with signing the exception
            relevantOSIPostions.forEach(val -> osiList.add(val.getOsi()));
        }
        return osiList;
    }

    private boolean isNotNonePositionCompleted(OrderStepInput osi) {
        return !isPlannedQtyModeNone(osi) && getModel().isPositionCompleted(osi);
    }

    /**
     * Setup signature executor list for failed checks
     *
     * @param signatureExecutor the signature executor from the signed checks
     * @param signedExceptions  the signed exceptions
     * @param checkSuite        the check suite containing the checks
     * @return list with the configured signature executor
     */
    private List<IESignatureExecutor> setupSignatureExecutor(final IESignatureExecutor signatureExecutor, final List<String> signedExceptions, final IIdentificationCheckSuite checkSuite) {
        for (int i = 0; checkSuite!=null && i < checkSuite.size(); i++) {
            IIdentificationCheck identificationCheck = checkSuite.get(i);
            if (!identificationCheck.isOk()) {
                signatureExecutor.addInfo(new ArrayList<>(identificationCheck.getExceptionList()));
                signedExceptions.addAll(identificationCheck.getExceptionList());
            }
        }
        List<IESignatureExecutor> signatures = new ArrayList<>();
        signatures.add(signatureExecutor);
        return signatures;
    }

    /**
     * Check if the additionally identified sublot should be consumed and consume it.
     *
     * @param sublot the identified order step input sublot
     */
    private void consumeSublotOnAction(OrderStepInputSublot sublot) {
        if (sublot == null) {
            return;
        }
        IMeasuredValue quantity;
        try {
            quantity = sublot.getIdentifiedQuantity();
        } catch (MESIncompatibleUoMException e1) {
            throw new MESRuntimeException(e1);
        }
        WarehouseRuntimeException lastWHException = null;
        final IOrderStepExecutionService osExecSrv = MaterialHelper0710.getOrderStepExecutionService();
        if (model.getAutoConsume() && quantity.signum() > 0) {
            try {
                osExecSrv.consumeSublotAttachedToOrderStepInput(sublot.getOrderStepInput(), quantity, true, StringUtilsEx.EMPTY);
            } catch (MESIncompatibleUoMException | MESQuantityMustNotBeNegativeException |
                     MESSublotOperationNotAllowedException e) {
                throw new MESRuntimeException(e);
            } catch (WarehouseRuntimeException e) {
                lastWHException = e;
            }

            try {
                deleteSublotLogically(ServiceFactory.getService(ISublotService.class), sublot.getOrderStepInput(), sublot.getSublot());
            } catch (MESQuantityExceedsAllowedVariationException e) {
                throw new MESRuntimeException(e);
            } catch (WarehouseRuntimeException e) {
                lastWHException = e;
            }

            if (lastWHException != null) {
                model.setLastWarehouseExceptionAndError(lastWHException, CONSUME_SUBLOT_WAREHOUSE_ERROR_MSG_ID);
            }
        }

    }

    /**
     * Get the original unsplitted OSI
     *
     * @param osi the OSI
     * @return the original unsplitted OSI
     */
    private OrderStepInput getUnsplittedOSI(OrderStepInput osi) {
        String originOSIName = MESNamedUDAOrderStepInput.getOriginOSIName(osi);
        for (OrderStepInput osii : model.getMasterOSIsForPhase()) {
            if (osii.getName().equals(originOSIName)) {
                return osii;
            }
        }
        return null;
    }

    @Override
    public void handleOSOCompleted(Long osoKey) {
        handleOSOCompletedOrSublotProducedFor(osoKey);
    }

    @Override
    public void handleSublotProducedFor(Long osoKey) {
        handleOSOCompletedOrSublotProducedFor(osoKey);
    }

    private void handleOSOCompletedOrSublotProducedFor(Long osoKey) {
        if (isOSOPredecessor(osoKey)) {
            // refresh because we have new produced sublots or planned qty might be calculated
            final boolean tryCalculationOfPlannedQty = true;
            refreshModelAndView(tryCalculationOfPlannedQty);
        }
    }

    private void refreshModelAndView(boolean tryCalculationOfPlannedQty) {
        model.getOrderStep(true);

        if (tryCalculationOfPlannedQty) {
            model.tryCalcPlannedQtyForDynAsProduced();
        }

        model.initMatInputList();
        model.refreshMaterialsList();
        getView().refreshView();
    }

    @Override
    protected boolean generateReportData() {
        List<MESRtPhaseDataMatAlterIdent0010> data = model.getAllRtPhaseData();
        // check if the entries already exist
        if (data.isEmpty()) {
            createPhaseData();
            return true;
        } else {
            return updatePhaseData();
        }
    }

    private void createPhaseData() {

        for (IdentifiedMaterialDAO0710 material : model.getMatInputList()) {
            MESRtPhaseDataMatAlterIdent0010 rtPhaseData = model.addRtPhaseData();
            rtPhaseData.setMaterialID(model.createPhaseDataMaterialID(material));
            rtPhaseData.setMfcPos(material.getMfcPosition());
            rtPhaseData.setIsHeader(true);
            rtPhaseData.setMaterialDescription(material.getDescription() == null ? " " : material.getDescription());
            rtPhaseData.setPlannedQty((MeasuredValue) material.getPlannedQtyMV());
            rtPhaseData.setPlannedQtyWithLimits(material.getPlannedQtyWithLimits());
            rtPhaseData.setPlannedQtyDisplString(material.getPurePlannedQtyDisplayString());
            rtPhaseData.setIdentifiedQty((MeasuredValue) material.getProcessedQtyMV());
            if (!StringUtils.isEmpty(material.getComment())) {
                rtPhaseData.setCommentToExecution(material.getComment().getBytes(Charset.defaultCharset()));
            }
            rtPhaseData.setBatchSublotDisplString(material.getRelatedBatchesSublotsDisplayString());
            rtPhaseData.setBatchIDStr(material.getBatch());
            rtPhaseData.setSublotIDStr(material.getSublot());
            rtPhaseData.setAccountedQty((MeasuredValue) material.getAccountedQtyMV());
            rtPhaseData.setAccountingStatus(material.getStatusString());
            rtPhaseData.setLocalIdentified(Boolean.FALSE);
            rtPhaseData.setResult(getModel().getPhaseResult().getKey());

            addAlreadyIdentifiedFromPreviousPhaseInstances(material);
        }
    }

    private void addAlreadyIdentifiedFromPreviousPhaseInstances(IdentifiedMaterialDAO0710 material) {
        final List<OrderStepInput> osiList = model.getMasterOSIsOfMaterial().get(material.getMaterialID());
        Optional<OrderStepInput> osiForMaterial = osiList.stream().filter(osi -> osi.getKey() == material.getOsiKey()).findFirst();
        if (osiForMaterial.isPresent()) {
            OrderStepInput osi = osiForMaterial.get();
            // if a sublot is released and no quantity was consumed: it was unidentified
            final IOrderStepExecutionService osExecSrv = MaterialHelper0710.getOrderStepExecutionService();
            List<OrderStepInputSublot> osiSublots = osExecSrv.getIdentifiedOSISublots(osi, false, false).stream().filter(osiSublot -> !(osiSublot.isReleased() && osiSublot.getConsumedQuantity() == null)).collect(Collectors.toList());
            if (!osiSublots.isEmpty()) {
                addAlreadyProcessedSublotsToPhaseData(model.createPhaseDataMaterialID(material), osiSublots);
            }
        }
    }

    /**
     * Adds already identified (from previous phase instances) positions to phase data
     *
     * @param materialIDExt a unique material ID to be used for phase data
     * @param osiSublots    list of added/removed sublots
     */
    private void addAlreadyProcessedSublotsToPhaseData(final String materialIDExt, final List<OrderStepInputSublot> osiSublots) {
        for (OrderStepInputSublot osiSublot : osiSublots) {
            MESRtPhaseDataMatAlterIdent0010 rtPhaseData = model.addRtPhaseData();
            rtPhaseData.setMaterialID(materialIDExt);
            rtPhaseData.setIsHeader(false);
            rtPhaseData.setMfcPos(MESNamedUDAOrderStepInput.getPosition(osiSublot.getOrderStepInput()));
            final String batchName = osiSublot.getBatch().getUniqueName();
            rtPhaseData.setBatchIDStr(batchName);
            final String sublotUniqueName = osiSublot.getSublot().getUniqueName();
            rtPhaseData.setSublotIDStr(sublotUniqueName);

            String displayString = model.createRelatedBatchesSublotsDisplayString(batchName, sublotUniqueName, "");
            rtPhaseData.setBatchSublotDisplString(displayString);
            IMeasuredValue identifiedQty = null;
            try {
                identifiedQty = osiSublot.getOriginalIdentifiedQuantity() != null ? //
                        osiSublot.getOriginalIdentifiedQuantity() : osiSublot.getIdentifiedQuantity();
            } catch (MESIncompatibleUoMException mesExc) {
                ProductPhaseSwingHelper.showErrorDlg(mesExc.getLocalizedMessage());
            }
            rtPhaseData.setIdentifiedQty((MeasuredValue) identifiedQty);
            rtPhaseData.setIsUnidentified(false);
            rtPhaseData.setResult(model.getPhaseResult().getKey());
            rtPhaseData.setLocalIdentified(model.isLocallyIdentified(sublotUniqueName));
        }
    }

    private boolean updatePhaseData() {
        boolean changed = updateHeaderPhaseData();
        return updateResultInPhaseData() || changed;
    }

    private boolean updateHeaderPhaseData() {
        List<MESRtPhaseDataMatAlterIdent0010> allRtPhaseData = model.getAllRtPhaseData();
        boolean changed = false;
        for (IdentifiedMaterialDAO0710 material : model.getMatInputList()) {
            final String materialIDExt = model.createPhaseDataMaterialID(material);
            MESRtPhaseDataMatAlterIdent0010 rtPhaseData = findHeaderDataRow(allRtPhaseData, materialIDExt);

            final IMeasuredValue accountedQtyMV = material.getAccountedQtyMV();

            if ((accountedQtyMV != null) && !accountedQtyMV.equals(rtPhaseData.getAccountedQty())) {
                rtPhaseData.setAccountedQty((MeasuredValue) accountedQtyMV);
                changed = true;
            }
            final String statusString = material.getStatusString();
            if ((statusString != null) && !statusString.equals(rtPhaseData.getAccountingStatus())) {
                rtPhaseData.setAccountingStatus(statusString);
                changed = true;
            }
            final String plannedQtyWithLimits = material.getPlannedQtyWithLimits();
            if ((plannedQtyWithLimits != null) && !plannedQtyWithLimits.equals(rtPhaseData.getPlannedQtyWithLimits())) {
                rtPhaseData.setPlannedQtyWithLimits(plannedQtyWithLimits);
                changed = true;
            }
            final String purePlannedQtyDisplStr = material.getPurePlannedQtyDisplayString();
            if ((purePlannedQtyDisplStr != null) && !purePlannedQtyDisplStr.equals(rtPhaseData.getPlannedQtyDisplString())) {
                rtPhaseData.setPlannedQtyDisplString(purePlannedQtyDisplStr);
                changed = true;
            }
            if (updateSublotsAndBatches(material, rtPhaseData)) {
                changed = true;
            }

        }
        return changed;
    }

    private boolean updateSublotsAndBatches(IdentifiedMaterialDAO0710 material, MESRtPhaseDataMatAlterIdent0010 rtPhaseData) {
        boolean changed = false;
        if (updateBlobInRtPhaseDataFromMaterial(material, rtPhaseData, IdentifiedMaterialDAO0710::getRelatedBatchesSublotsDisplayString, MESRtPhaseDataMatAlterIdent0010::getBatchSublotDisplString, MESRtPhaseDataMatAlterIdent0010::setBatchSublotDisplString)) {
            changed = true;
        }
        if (updateBlobInRtPhaseDataFromMaterial(material, rtPhaseData, IdentifiedMaterialDAO0710::getBatchStr, MESRtPhaseDataMatAlterIdent0010::getBatchIDStr, MESRtPhaseDataMatAlterIdent0010::setBatchIDStr)) {
            changed = true;
        }
        if (updateBlobInRtPhaseDataFromMaterial(material, rtPhaseData, IdentifiedMaterialDAO0710::getSublot, MESRtPhaseDataMatAlterIdent0010::getSublotIDStr, MESRtPhaseDataMatAlterIdent0010::setSublotIDStr)) {
            changed = true;
        }
        return changed;
    }

    private boolean updateBlobInRtPhaseDataFromMaterial(IdentifiedMaterialDAO0710 material, MESRtPhaseDataMatAlterIdent0010 rtPhaseData, Function<IdentifiedMaterialDAO0710, String> getterMaterial, Function<MESRtPhaseDataMatAlterIdent0010, String> getter, BiConsumer<MESRtPhaseDataMatAlterIdent0010, String> setter) {
        boolean changed = false;
        final String newValue = convertNullToEmptyString(getterMaterial.apply(material));
        final String oldValue = convertNullToEmptyString(getter.apply(rtPhaseData));

        if (!newValue.equals(oldValue) && !isWorkAroundEmptyValueSetAndDoClear(newValue, oldValue)) {
            setter.accept(rtPhaseData, newValue);

            workAroundClearBlobBug(rtPhaseData, newValue, oldValue, setter, getter);
            changed = true;
        }

        return changed;
    }

    private boolean isWorkAroundEmptyValueSetAndDoClear(final String newValue, final String oldValue) {
        return newValue.equals(StringUtils.EMPTY) && isWorkAroundValueForEmptySet(oldValue);
    }

    private String convertNullToEmptyString(String value) {
        return (value == null) ? StringUtils.EMPTY : value;
    }

    private void workAroundClearBlobBug(MESRtPhaseDataMatAlterIdent0010 rtPhaseData, final String newValue, String oldValue, BiConsumer<MESRtPhaseDataMatAlterIdent0010, String> setter, Function<MESRtPhaseDataMatAlterIdent0010, String> getter) {
        if (StringUtils.isEmpty(newValue) && StringUtils.isNotEmpty(oldValue) && !isWorkAroundValueForEmptySet(oldValue) && StringUtils.isNotEmpty(getter.apply(rtPhaseData))) {
            // But it was not successfully
            setter.accept(rtPhaseData, WORK_AROUND_BLOB_VALUE_FOR_EMPTY);
            LOGGER.debug("######################## after writing blank " + getter.apply(rtPhaseData) + " oldValue=" + oldValue);
            if (StringUtils.isNotBlank(getter.apply(rtPhaseData))) {
                LOGGER.error("************* WorkAround not successfull, blob not cleared. Value is " + getter.apply(rtPhaseData));
            }
        }
    }

    private boolean isWorkAroundValueForEmptySet(String oldValue) {
        return WORK_AROUND_BLOB_VALUE_FOR_EMPTY.equals(oldValue);
    }

    private boolean updateResultInPhaseData() {
        boolean changed = false;
        final String phaseResult = getModel().getPhaseResult().getKey();
        List<MESRtPhaseDataMatAlterIdent0010> allRtPhaseData = model.getAllRtPhaseData();

        for (MESRtPhaseDataMatAlterIdent0010 rtPhaseData : allRtPhaseData) {

            if (!phaseResult.equals(rtPhaseData.getResult())) {
                rtPhaseData.setResult(phaseResult);
                changed = true;
            }
        }
        return changed;
    }

    @Override
    protected void updateDataRows(final String materialID, String mfcPosition, final String osiNumber, final List<Sublot> sublots, final String logisticUnitID, final boolean add) {
        // find the header row to update the identified quantity
        List<MESRtPhaseDataMatAlterIdent0010> allRtPhaseData = model.getAllRtPhaseData();
        String materialIDExt = model.createPhaseDataMaterialID(materialID, osiNumber);
        MESRtPhaseDataMatAlterIdent0010 headerData = findHeaderDataRow(allRtPhaseData, materialIDExt);

        MeasuredValue headerIdentifiedQty = headerData.getIdentifiedQty();
        IMeasuredValueConverter converter = sublots.isEmpty() //
                ? null : PartRelatedMeasuredValueUtilities.getMeasuredValueConverterForPart(sublots.get(0).getPart());
        for (Sublot sublot : sublots) {
            if (add) {
                MESRtPhaseDataMatAlterIdent0010 rtPhaseData = model.addRtPhaseData();
                rtPhaseData.setMaterialID(materialIDExt);
                rtPhaseData.setMfcPos(mfcPosition);
                rtPhaseData.setIsHeader(false);
                final String batchName = sublot.getBatch().getUniqueName();
                rtPhaseData.setBatchIDStr(batchName);
                final String sublotName = sublot.getUniqueName();
                rtPhaseData.setSublotIDStr(sublotName);
                final String relatedBatchesSublotsDisplayString = model.createRelatedBatchesSublotsDisplayString(batchName, sublotName, "");
                rtPhaseData.setBatchSublotDisplString(relatedBatchesSublotsDisplayString);
                rtPhaseData.setLogisticUnitID(logisticUnitID);
                MeasuredValue qty = (MeasuredValue) model.convertMeasuredValue(sublot.getQuantity(), headerIdentifiedQty.getUnitOfMeasure(), converter);
                rtPhaseData.setIdentifiedQty(qty);
                rtPhaseData.setIsUnidentified(false);
                rtPhaseData.setLocalIdentified(true);
                rtPhaseData.setResult(model.getPhaseResult().getKey());
                model.addLocalIdentifiedSublot(sublot);
                try {
                    headerIdentifiedQty = MeasuredValueUtilities.addArgsOptional(headerIdentifiedQty, sublot.getQuantity(), converter);
                } catch (MESIncompatibleUoMException e) {
                    throw new MESRuntimeException(e);
                }
            } else {
                MESRtPhaseDataMatAlterIdent0010 data = findDataRowForSublot(allRtPhaseData, materialIDExt, sublot);
                if (data != null) {
                    try {
                        headerIdentifiedQty = (MeasuredValue) headerIdentifiedQty.subtract(data.getIdentifiedQty());
                    } catch (Exception e) {
                        ProductPhaseSwingHelper.showErrorDlg(e.getLocalizedMessage());
                    }
                    // mark the row as unidentified: will be ignored in the subreport
                    data.setIsUnidentified(true);
                    model.removeLocalIdentifiedSublot(sublot);
                }
            }
        }

        // update the header row
        headerData.setIdentifiedQty(headerIdentifiedQty);
    }

    private MESRtPhaseDataMatAlterIdent0010 findHeaderDataRow(List<MESRtPhaseDataMatAlterIdent0010> allRtPhaseData, String materialIDExt) {
        for (MESRtPhaseDataMatAlterIdent0010 data : allRtPhaseData) {
            if (data.getIsHeader() && data.getMaterialID().trim().equals(materialIDExt)) {
                return data;
            }
        }
        throw new MESRuntimeException("The specified material ID cannot be found in the phase data");
    }

    private MESRtPhaseDataMatAlterIdent0010 findDataRowForSublot(List<MESRtPhaseDataMatAlterIdent0010> allRtPhaseData, String materialIDExt, Sublot sublot) {

        for (MESRtPhaseDataMatAlterIdent0010 data : allRtPhaseData) {
            if (!data.getIsHeader() && data.getMaterialID().equals(materialIDExt) && data.getSublotIDStr().equals(sublot.getUniqueName()) && !data.getIsUnidentified()) {
                return data;
            }
        }
        return null;
    }

    /**
     * initialize identification checks
     */
    private void initChecks() {
        Map<String, Object> allocatedBatches = getAllocatedBatches(null);
        identCheckSuite = new PhaseIdentificationCheckSuite0710(getParameters(), allocatedBatches);
    }

        /**
         * Create a map of allocated batches for each material
         *
         * @param materialIdFilter material identifier filter
         * @return map of allocated batches for each material
     */
    private Map<String, Object> getAllocatedBatches(String materialIdFilter) {
        Map<String, Object> allocatedBatches = new HashMap<>();
        for (IdentifiedMaterialDAO0710 matInputParam : model.getMatInputList()) {
            String matId = matInputParam.getMaterialIDStr();
            String batches = matInputParam.getBatchStr();
            if (matId != null && (materialIdFilter == null || matId.equals(materialIdFilter)) && batches != null && !batches.isEmpty()) {
                allocatedBatches.put(matId, batches);

            }
        }
        return allocatedBatches;
    }

    @Override
    protected MatIdentModel0710 createModel() {
        return new MatIdentModel0710(this);
    }

    @Override
    protected MatIdentView0710 createView(MatIdentModel0710 theModel) {
        return new MatIdentView0710(model, this);
    }

    @Override
    protected MatIdentExceptionView0710 createExceptionView(MatIdentModel0710 theModel) {
        model.initOrderStep();
        return new MatIdentExceptionView0710(theModel, this);
    }

    @Override
    protected ActionView0710 createActionView(MatIdentModel0710 theModel) {
        if (!isYoungestRtPhaseInstance()) {
            return null;
        }
        model.initOrderStep();
        initChecks();

        model.refreshMaterialsList();
        return new ActionView0710(theModel, this);
    }

    private boolean isYoungestRtPhaseInstance() {
        final IS88ExecutionService execService = ServiceFactory.getService(IS88ExecutionService.class);
        return execService.isYoungestRtPhase(getRtPhase());
    }

    /**
     * 点击phase确认完成时 方法
     */
    @Override
    protected void performPhaseCompletion() {
        // remove the listeners after complete
        //删除侦听器
        if (messageController != null) {
            messageController.stopReceivingMessages();
        }
        generateReportData();
        model.logPhaseData("At Phase Completion");
        getModel().setPhaseOutputData();
    }

    /**
     * 点击phase确认时 逻辑检查
     * @return
     */
    @Override
    protected boolean performPhaseCompletionCheck() {
        // Refresh first on completion:
        //完成后首先刷新：
        onRefresh();
        // Focus gets lost by pressing complete button. Re-enable barcode scanning
        // //按下完成按钮会失去焦点。重新启用条形码扫描
        getView().reenableBarcodeScanning();
        /**
         * tx
         * lc
         */
        masterOsiException = null;
        totalConsumedQtyException = null;


        if (!doCompletionChecks()) {
            return false;
        }

        //dustin:自消耗增加替代比例不一致校验
        if (model.getAutoConsume()) {
//            if (model.checkCombineGroupIsEqualWithRate() == false) {
//                final String isContinueMsg = I18nMessageUtility.getLocalizedMessage(MaterialModel0710.PHASE_PRODUCT_MATERIAL_MSGPACK, "CombineGroupIsEqualWithRate_Error");
//                PhaseQuestionDialog questionDialog = new PhaseQuestionDialog();
//                int userChoice = questionDialog.showDialog(isContinueMsg);
//                if (userChoice != 0) {
//                    return false;
//                }
//            }
        }

        if (!consumeSublots()) {
            getView().lockCompleteButton();
            return false;
        }
        return true;
    }

    /**
     * 完成按钮 检查方法
     * @return
     */
    private boolean doCompletionChecks() {
        final boolean isDone = getModel().isPhaseResultDone();
        //是否强制完成判断
        final boolean isForceCompletion = isForceCompletionExceptionSigned();

        if (isDone && !isForceCompletion) {
            //没有强制完成
            String errorText = getCompletionErrors(false);
            //System.out.println(errorText);
            if (!StringUtils.isEmpty(errorText)) {
                showErrorAndLockCompleteButton(errorText);
                return false;
            }
        }
        /**
         * 检查上下限公差
         */
        return doLimitChecks();
    }

    /**
     * 判断是否强制完成（检查是否有强制完成的签名）
     * @return
     */
    private boolean isForceCompletionExceptionSigned() {
        return isExceptionSigned(KEY_FORCE_COMPLETION);
    }

    private boolean doLimitChecks() {
        if (model.isBlockedByWarehouseError()) {
            final String signWarehouseErrorText = I18nMessageUtility.getLocalizedMessage(MaterialModel0710.PHASE_PRODUCT_MATERIAL_MSGPACK, "SignWarehouseError_Error");
            ProductPhaseSwingHelper.showErrorDlg(signWarehouseErrorText);
            return false;
        }
        getModel().clearQuantityRangeConditions();
        MatIdentCompletionExceptions0710 exceptionsChecker = new MatIdentCompletionExceptions0710(this);
        if (!exceptionsChecker.checkAndHandleExceptions()) {
            getView().lockCompleteButton();
            return false;
        }
        return true;
    }

    private String getCompletionErrors(boolean exceptionText) {
        final StringBuilder errorTextBuilder = new StringBuilder();
        if (isAsProducedPlannedQtyNotYetCalculated()) {
            errorTextBuilder.append(getI18nError(getMsgIdCompletionError(exceptionText, "AsProducedPredecessorStillOpen_Error")));
        }
        List<Sublot> sublotsToIdentify = getSublotsNeedToIdentify();
        if (!sublotsToIdentify.isEmpty()) {
            appendLineBreaksIfNeeded(errorTextBuilder);
            errorTextBuilder.append(getSublotsToIdentifyI18nError(exceptionText, sublotsToIdentify));
        }
        //是否启用自消耗
        if (model.getAutoConsume()) {
            /**
             * 除了主料，其他辅料物料都不能为0 kg识别量 或 没有消耗量
             */
            if (model.hasMandatoryPositionsWithoutIdentifications()) {
                appendLineBreaksIfNeeded(errorTextBuilder);
                errorTextBuilder.append(getI18nError(getMsgIdCompletionError(exceptionText, "NotAllMaterialIdentified_Error")));
            }
        }
        /**
         * 没有启用自消耗
         */
        else {
            if (isMandatoryPositionOpen()) {
                /**
                 * 除了主料，其他辅料物料都不能为0 kg消耗量 或 没有消耗量
                 */
                //Phase不能完成
                appendLineBreaksIfNeeded(errorTextBuilder);
                errorTextBuilder.append(getI18nError(getMsgIdCompletionError(exceptionText, "MatIdentPositionStillOpen_Error")));
            }
        }
        return errorTextBuilder.toString();
    }

    private String getMsgIdCompletionError(boolean exceptionText, String mainPartMsgId) {
        if (exceptionText) {
            return KEY_FORCE_COMPLETION + mainPartMsgId;
        } else {
            return "CannotComplete" + mainPartMsgId;
        }
    }

    private void appendLineBreaksIfNeeded(final StringBuilder errorTextBuilder) {
        if (!StringUtils.isEmpty(errorTextBuilder.toString())) {
            errorTextBuilder.append(StringConstants.LINE_BREAK);
        }
    }

    private String getSublotsToIdentifyI18nError(boolean exceptionText, List<Sublot> sublotsToIdentify) {
        String sublotsAsString = sublotsToIdentify.stream().map(Sublot::getName).collect(Collectors.joining(", "));
        return I18nMessageUtility.getLocalizedMessage(MSG_PACK, getMsgIdCompletionError(exceptionText, "SublotsToIdentify_Error"), new Object[]{sublotsAsString});
    }

    private void showErrorAndLockCompleteButton(String localizedError) {
        ProductPhaseSwingHelper.showErrorDlg(localizedError);
        getView().lockCompleteButton();
    }

    private List<Sublot> getSublotsNeedToIdentify() {
        List<Sublot> sublotsToIdentify = new ArrayList<>();
        for (OrderStepInput masterOSI : model.getMasterOSIsForPhase()) {
            if (isPlannedQtyModeNone(masterOSI) || masterOSI.getProcessingType() != OrderStepInput.INPUT_TYPE_INTERMEDIATE) {
                continue;
            }
            sublotsToIdentify.addAll(MaterialHelper0710.getOrderStepExecutionService().getNotIdentifiedButProducedSublotsForTheOSI(masterOSI));
        }

        return sublotsToIdentify;
    }

    private boolean isAsProducedPlannedQtyNotYetCalculated() {
        for (OrderStepInput masterOsi : model.getMasterOSIsOfMaterialWithAsProduced()) {
            if (MesClassUtility.longToBool(MESNamedUDAOrderStepInput.getPlannedQtyNotYetCalculated(masterOsi), true)) {
                return true;
            }
        }
        return false;
    }

    /*
    异常事务回调
     */
    @Override
    protected void exceptionTransactionCallback(String checkKey, IMESExceptionRecord exceptionRecord, IESignatureExecutor sigExecutor) {
        System.out.println(checkKey);
        if (checkKey.equals(KEY_ADDITIONAL_ACTION)) {
            handleIdentificationInTransaction(sigExecutor, true);
        } else if (checkKey.equals(KEY_MANUAL_EXC)) {
            handleIdentificationInTransaction(sigExecutor, false);
        } else if (checkKey.equals(KEY_UNDO_ACTION) || checkKey.equals(KEY_UNDO_EXC)) {
            undoIdent();
        } else if (checkKey.equals(KEY_IDENTIFICATION)) {
            handleIdentificationInTransaction(sigExecutor, false);
        }
        else if (checkKey.equals(KEY_MATERIAL_HYBRID_EXCEPTION)) {
            //handleIdentificationInTransaction(sigExecutor, false);
        }else if(checkKey.equals(KEY_PROPORTIONALANOMALY)){
            //handleIdentificationInTransaction(sigExecutor, false);
        } else if(checkKey.equals(KEY_INSUFFICIENTRECOGNITIONQUANTITY)){
            //handleIdentificationInTransaction(sigExecutor, false);
        }
          else if (!KEY_FORCE_COMPLETION.equals(checkKey) //
                && !checkKey.equals(AbstractMaterialPhaseExecutor0710.WAREHOUSE_ERROR_CHECK_KEY) && !MatIdentCompletionExceptions0710.isCompletionCheck(checkKey)) {
            throw new MESRuntimeException("Action not supported! ");
        }
    }

    @Override
    public void exceptionSigned(String checkKey) {
        exceptionSigned(checkKey, null);
    }

    /**
     * 点击签名后 执行的方法
     * @param checkKey
     * @param afterCommitException
     */
    @Override
    public void exceptionSigned(String checkKey, final MESRuntimeException afterCommitException) {
        if(KEY_MATERIAL_HYBRID_EXCEPTION.equals(checkKey)){
            //在这里更新子批次、绑定子批次
            IPhaseIdentificationCheckSuite0710 checksuite = null;
            try {
                checksuite = performIdentification( null, false);
            } catch (MESException e) {
                throw new RuntimeException(e);
            } catch (DatasweepException e) {
                throw new RuntimeException(e);
            }
            evaluateIdentificationRequestResult(checksuite);
        }
        if (AbstractMaterialPhaseExecutor0710.WAREHOUSE_ERROR_CHECK_KEY.equals(checkKey)) {
            try (AutoWaitCursor waitCursor = new AutoWaitCursor(getView())) {
                getModel().resetLastWarehouseExceptionAndError();
                triggerAutoCompleteAfterReturnFromExceptionView();
            }
        } else {
            getView().refreshView();
            if (checkKey.equals(KEY_ADDITIONAL_ACTION) && afterCommitException != null && afterCommitException instanceof WarehouseRuntimeException) {
                final WarehouseRuntimeException lastWHException = (WarehouseRuntimeException) afterCommitException;
                model.setLastWarehouseExceptionAndError(lastWHException, CONSUME_SUBLOT_WAREHOUSE_ERROR_MSG_ID);
                final String erroMessage = model.createWarehouseErrorMessage(MSG_PACK, null, false);
                ProductPhaseSwingHelper.showErrorDlg(erroMessage);
                model.recordSystemTriggeredWarehouseInteractionException(erroMessage);
                model.resetLastWarehouseExceptionAndError();
            }
        }
        boolean triggerAutoComplete = KEY_FORCE_COMPLETION.equals(checkKey) || MatIdentCompletionExceptions0710.isCompletionCheck(checkKey);
        if (KEY_FORCE_COMPLETION.equals(checkKey)) {
            getView().selectDoneButtonAndDisable();
        }
        if (triggerAutoComplete) {
            model.setPhaseBlocked();
            triggerAutoCompleteAfterReturnFromExceptionViewWithWaitCursor();
        }
    }

    private void triggerAutoCompleteAfterReturnFromExceptionViewWithWaitCursor() {
        try (AutoWaitCursor waitCursor = new AutoWaitCursor(getView())) {
            triggerAutoCompleteAfterReturnFromExceptionView();
        }
    }

    private void handleIdentificationInTransaction(IESignatureExecutor sigExecutor, boolean isAction) {
        IPhaseIdentificationCheckSuite0710 checksuite;
        try {
            checksuite = performIdentification(sigExecutor, isAction);
        } catch (MESException | DatasweepException e) {
            throw new MESRuntimeException(e.getLocalizedMessage());
        }
        String errorList = checksuite.getCollectedErrorMessage();
        if (!errorList.isEmpty()) {
            // if there are errors: identification cannot be done
            throw new MESRuntimeException(errorList);
        } else {
            String excList = checksuite.getCollectedExceptionMessage();
            if (!excList.isEmpty()) {
                throw new MESRuntimeException(excList);
            }
        }
    }

    @Override
    public void onWarehouseErrorRecordRequest() {
        model.fillRecordWarehouseErrorException(MSG_PACK, null);
    }


    /**
     * MixCheckConfiguration过参
     * @return
     */
    public MESParamExcptEnableDef0200 getMixCheckConfiguration(){
        return getProcessParameterData(MESParamExcptEnableDef0200.class,"Mix check configuration");
    }

    /**
     * 识别量 过参
     * @return
     */
    public MESParamExceptionDef0300 getRecognitionQuantityInsufficient(){
        return getProcessParameterData(MESParamExceptionDef0300.class,"RecognitionQuantityInsufficient");
    }

    /**
     * 组合比例不一致 过参
     * @return
     */
    public MESParamExceptionDef0300 getProportionalAnomaly(){
        return getProcessParameterData(MESParamExceptionDef0300.class,"Proportional Anomaly");
    }

    /**
     * 物料流入控制 过参
     * @return
     */
    public MESParamMatPositionCtr0100 getMaterialPosiControl(){
        return getProcessParameterData(MESParamMatPositionCtr0100.class,"Material position control");
    }





    /**
     * 扫描开始校验
     */
    @Override
    public void onIdent() {
        if (!isIdentificationAllowed()) {
            return;
        }
        IPhaseIdentificationCheckSuite0710 checksuite = null;
        try {
            // get the identified item 获取扫描的子批次对象
            identifiedItem = getIdentifiedItemByBarcode(getView().getEnteredBarcode());
            if(getMaterialPosiControl().getEnable() != null && getMaterialPosiControl().getEnable()){
                //开启子批次 存储位置、存储区域校验
                if(!CheckMaterialLocationRule()){
                    //校验不通过
                    return;
                }
            }
            //判断是否启用了扫描描混合检查的过参
            if(getMixCheckConfiguration().getEnabled()){
                //开启，判断子批次与表格中的子批次是否为同一组物料或同一个物料
                if(!CheckMaterialRule(1)){
                    return;
                } else{

                    checksuite = performIdentification( null, false);
                    evaluateIdentificationRequestResult(checksuite);
                }
            } else{
                checksuite = performIdentification( null, false);
                evaluateIdentificationRequestResult(checksuite);
            }
        } catch (MESException | DatasweepException e) {
            ProductPhaseSwingHelper.showErrorDlg(e.getLocalizedMessage());
            return;
        }
    }

    private boolean isIdentificationAllowed() {
        if (model.isBlockedByWarehouseError()) {
            final String signWarehouseErrorText = I18nMessageUtility.getLocalizedMessage(MaterialModel0710.PHASE_PRODUCT_MATERIAL_MSGPACK, "SignWarehouseError_Error");
            ProductPhaseSwingHelper.showErrorDlg(signWarehouseErrorText);
            return false;
        }
        if (noFurtherIdentifcation()) {
            showMustLoopError();
            return false;
        }
        return !model.isPhaseBlocked();
    }

    private boolean noFurtherIdentifcation() {
        return model.mustLoop() && model.isIdentificationDone();
    }

    private void showMustLoopError() {
        String localizedError = I18nMessageUtility.getLocalizedMessage(MSG_PACK, "MustLoopAfterIdentification_Error");
        ProductPhaseSwingHelper.showErrorDlg(localizedError);
    }


    private void evaluateIdentificationRequestResult(IPhaseIdentificationCheckSuite0710 checksuite) {
        //校验子批次是否已经被识别，返回message错误提示
        if(checksuite == null){
            getView().refreshView();
            return;
        }
        String errorList = checksuite.getCollectedErrorMessage();
        if (!errorList.isEmpty()) {
            //有错误提示
            // if there are errors: show error dialog, identification cannot be done
            if (identifiedItem.isLogisticUnit()) {
                // in case of logistic unit the error list can be quite long
                // therefore we use error dialog with details
                final String errorMsg = I18nMessageUtility.getLocalizedMessage(MSG_PACK, "LUCannotIdentifyErrors_ErrorMsg", new String[]{identifiedItem.getName()});
                new ErrorDialogWithDetails().showDialog(errorMsg, errorList);
            } else {
                ProductPhaseSwingHelper.showErrorDlg(errorList);
            }
            return;
        }

        //String excList = checksuite.getCollectedExceptionMessage();
//        if (!excList.isEmpty()
//                /**
//                 * SCL
//                 */ || MapUtils.isEmpty(sclCheckExceptionMessage) == false) {
//            PhaseWarningDialog excDialog = new PhaseWarningDialog();
//            //是否存在区域位置不对的异常
//            boolean locationExceptionFlag = false;
//            StringBuilder stringBuilderExcDialog = new StringBuilder();
//            if (MapUtils.isNotEmpty(sclCheckExceptionMessage)) {
//                if (sclCheckExceptionMessage.containsKey("Location Violation Exception")) {
//                    locationExceptionFlag = true;
//                }
//                sclCheckExceptionMessage.forEach((k, v) -> {
//                    stringBuilderExcDialog.append(StringConstants.LINE_BREAK);
//                    stringBuilderExcDialog.append(StringUtils.join(v, ","));
//                });
//
//                excList = excList + stringBuilderExcDialog;
//            }
//            //直接报错提示
//            if (locationExceptionFlag){
//                ProductPhaseSwingHelper.showErrorDlg(excList);
//                return;
//            }
//
//            int userChoice = excDialog.showDialog(excList);
//            if (userChoice == IExceptionHandler.OK_OPTION) {
//                String exceptionText;
//                AtomicLong maxRisk = new AtomicLong();
//                if (identifiedItem.isLogisticUnit()) {
//                    final StringBuilder exceptionTextBuilder = new StringBuilder(I18nMessageUtility.getLocalizedMessage(MSG_PACK, "LUIdentMsg", new Object[]{identifiedItem.getName()}));
//                    exceptionTextBuilder.append(StringConstants.LINE_BREAK);
//                    exceptionTextBuilder.append(StringConstants.LINE_BREAK);
//                    exceptionTextBuilder.append(checksuite.getCollectedExtendedExceptionMessage());
//                    exceptionText = exceptionTextBuilder.toString();
//                } else {
//                    exceptionText = checksuite.getCollectedExtendedExceptionMessage();
//                    StringBuilder stringBuilder = new StringBuilder();
//
//                    if (StringUtils.isEmpty(exceptionText) == false) {
//                        stringBuilder.append(exceptionText);
//                    }
//
//                    int loopCount = 1;
//                    for (Map.Entry<String, List<String>> item : sclCheckExceptionMessage.entrySet()) {
//                        String k = item.getKey();
//                        List<String> v = item.getValue();
//
//                        String msg = StringUtils.EMPTY;
//                        if (CollectionUtils.isNotEmpty(v)) {
//                            if (Objects.nonNull(sclKeyExceptionMap.get(k)) && sclKeyExceptionMap.get(k).getEnabled()) {
//                                msg = sclKeyExceptionMap.get(k).getMessage();
//                                System.out.println(k + "\t" + maxRisk.get());
//                                maxRisk.set(Math.max(sclKeyExceptionMap.get(k).getRiskAssessment(), maxRisk.get()));
//                                System.out.println(k + "\t" + msg);
//                                System.out.println(k + "\t" + maxRisk.get());
//
//                                stringBuilder.append(StringConstants.LINE_BREAK);
//                                stringBuilder.append(StringConstants.LINE_BREAK);
//                                stringBuilder.append(msg);
//                                stringBuilder.append(StringConstants.LINE_BREAK);
//                                stringBuilder.append(StringConstants.LINE_BREAK);
//                                stringBuilder.append(StringUtils.join(v, ","));
//                            }
//                        }
//
//                    }
//
////                    sclCheckExceptionMessage.forEach((k, v) -> {
////                        stringBuilder.append(StringConstants.LINE_BREAK);
////                        stringBuilder.append(StringConstants.LINE_BREAK);
////
////                        String msg = StringUtils.EMPTY;
////                        if (CollectionUtils.isNotEmpty(v)) {
////                            if (Objects.nonNull(sclKeyExceptionMap.get(k)) && sclKeyExceptionMap.get(k).getEnabled()) {
////                                msg = sclKeyExceptionMap.get(k).getMessage();
////                                System.out.println(k + "\t" + maxRisk.get());
////                                maxRisk.set(Math.max(sclKeyExceptionMap.get(k).getRiskAssessment(), maxRisk.get()));
////                                System.out.println(k + "\t" + msg);
////                                System.out.println(k + "\t" + maxRisk.get());
////                            }
////                        }
////                        stringBuilder.append(msg + StringConstants.LINE_BREAK);
////                        stringBuilder.append(StringUtils.join(v, ","));
////                    });
//                    exceptionText = stringBuilder.toString();
//                }
//
//                displayException(KEY_IDENTIFICATION, ChoiceLists0710.getRiskClass(Math.max(checksuite.getCollectedMaxRisk(), maxRisk.get())), exceptionText);
//            }
//            return;
//        }

        // no errors or exceptions: identification was successful
        getView().refreshView();

    }

    /**
    tanxin
    LC
     check 1：扫描
     check 2：手动
     */
    public Boolean CheckMaterialRule(int check){
        //重启、解绑操作重新进入，但界面上还是存在绑定的子批次，那当前扫描的子批次将作为“首次扫描”不进行是否同组下的物料检查
        //当前扫描的物料是为主料 或 替代物料 或组合替代物料
        String partID = identifiedItem.getSublot().getPartNumber();
        //获取物料输入参数列表
        if(model.getMaterialList().size() == model.getMasterOSIsForPhase().size()){
            materialTypeFinal.clear();
        }
        for (IdentifiedMaterialDAO0710 material : model.getMatInputList()) {
            if (material.getMaterialID().equals(partID)){
                //物料编码相同 判断是主料、单个替代物料、组合替代物料 0：啥都不是 1：主料(替代组号) 2：替代物料（替代组号） 3：组合替代物料（组合组号）
                HashMap<Integer, String> stringHashMap = CheckMaterialIsWhichPart(material.getMaterialID());
                if(stringHashMap == null){
                    return false;
                }
                if(materialTypeFinal.isEmpty()){
                    //首次进入扫描，将“物料类型 1 / 2 / 3 ”存入字段中，用于下一次子批次扫描判断
                    for(int key : stringHashMap.keySet()){
                        materialTypeFinal.put(key,stringHashMap.get(key));
                        return true;
                    }
                }else{
                    //大于第一次进入 遍历当前扫描子批次的物料 是什么类型， 判断是否与存入的materialTypeFinal值一致
                    for(int key : stringHashMap.keySet()){
                        if(materialTypeFinal.containsKey(key) && (stringHashMap.get(key)).equals(materialTypeFinal.get(key))){
                            //相同 不走异常
                            return true;
                        }else{
                            //不相同 走异常
                            PhaseQuestionDialog questionDialog = new PhaseQuestionDialog();
                            int torf = questionDialog.showDialog(MSG_PACK, "MaterialHybridException", new Object[]{identifiedItem.getName()});
                            if (torf != 0) {
                                //选择的取消/否 不做任何操作
                                return false;
                            }
                            if (check == 1){
                                //使用扫描子批次的方式
                                String msg = I18nMessageUtility.getLocalizedMessage(MSG_PACK, "MaterialHybridExceptionMeg", new Object[]{identifiedItem.getName()});
                                MESParamExcptEnableDef0200 def = getMixCheckConfiguration();
                                String exceptionStr = def.getMessage() + "\r\n" + msg;
                                long risk = def.getRiskAssessment();
                                RiskClass riskclass = RiskClass.valueOf(risk);
                                Boolean exceptionValue =  displayException(KEY_MATERIAL_HYBRID_EXCEPTION,riskclass,exceptionStr);
                                if(exceptionValue){
                                    //如果签名创建成功 去签名后执行子批次校验
                                    return false;
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    }

    /**
     * 获取物料为主料、单个替代物料、组合替代物料类型
     * @param partID
     * @return 0：什么都不是 1：主料 2：单个替代物料 3：组合替代物料
     */
    public HashMap<Integer, String> CheckMaterialIsWhichPart(String partID){
        HashMap<Integer, String> map = new HashMap<Integer,String>();
        List<IMESMaterialParameter> matParamList;
        MESNamedUDAMaterialParameter matParam = null;
        List<OrderStepInput> allMasterOSIs = model.getMasterOSIsForPhase();
        List<IMESMaterialParameter> materialParameters = getPhase().getMaterialParameters();
        for(OrderStepInput msterosi:allMasterOSIs){
            //单个物料行对象
            String partNumber = msterosi.getPart().getPartNumber();
            if(!partNumber.equals(partID)){
                continue;
            }
            if(isPlannedQtyModeNone(msterosi)){
                return null;
            }
            matParamList = materialParameters.stream().filter(p -> p.getMaterial() == msterosi.getPart() && p.getATRow().getValue("LC_isMainPart") != null && (Boolean) p.getATRow().getValue("LC_isMainPart")).collect(Collectors.toList());
            if(matParamList.size() > 0){
                //主料 返回“1”类型
                matParam = new MESNamedUDAMaterialParameter(matParamList.get(0));
                //获取主料 替代组号
                String masterReplaceGroupName = matParam.getReplaceGroupName();
                map.put(1,masterReplaceGroupName+partNumber);
                return map;
            }
            matParamList = materialParameters.stream().filter(p -> p.getMaterial() == msterosi.getPart() && p.getATRow().getValue("LC_isMainPart") == null && p.getATRow().getValue("LC_combinationGroup") == null).collect(Collectors.toList());
            if(matParamList.size() > 0){
                //单个替代物料 返回“2”类型
                matParam = new MESNamedUDAMaterialParameter(matParamList.get(0));
                //获取替代组号
                String masterReplaceGroupName = matParam.getReplaceGroupName();
                map.put(2,masterReplaceGroupName+partNumber);
                return map;
            }
            matParamList = materialParameters.stream().filter(p -> p.getMaterial() == msterosi.getPart() && p.getATRow().getValue("LC_combinationGroup") != null).collect(Collectors.toList());
            if(matParamList.size() > 0){
                //组合替代物料 返回“3”类型
                matParam = new MESNamedUDAMaterialParameter(matParamList.get(0));
                //获取 组合组号
                String combinationGroup = matParam.getCombinationGroup();
                //获取主料 替代组号
                String replaceGroupName = matParam.getReplaceGroupName();
                map.put(3,replaceGroupName+combinationGroup);
                return map;
            }
        }
        return null;
    }


    /**
     * 子批次存储区域、存储位置校验
     * true:校验通过
     */
    public Boolean CheckMaterialLocationRule(){
        //获取子批次的位置
        String locationStr = identifiedItem.getSublot().getCarrier().getLocation();
        if(locationStr == null){
            return false;
        }
        //通过位置Str获取存储位置
        Location location = PCContext.getFunctions().getLocation(locationStr);
        //通过存储位置获取存储区域
        String  parentLocationStr = location.getParentLocation().toString();
        if(parentLocationStr == null){
            return false;
        }

        //获取phase中配置的 存储区域、存储位置
        String storageArea = getMaterialPosiControl().getStorageArea();
        String storageLocation = getMaterialPosiControl().getStorageLocation();
        String msg = I18nMessageUtility.getLocalizedMessage(MSG_PACK, "IdentifyMaterialLocation_Error");
        if(storageArea == null && storageLocation == null){
            //存储区域、存储位置都为空 不进行校验
            return true;
        }else if(storageArea != null && storageLocation != null){
            //存储区域，存储位置都不为空，判断子批次的存储位置、区域是否与处方中设置的存储位置、区域一致
            if(!storageArea.equals(parentLocationStr) || !storageLocation.equals(locationStr)){
                ProductPhaseSwingHelper.showErrorDlg(msg);
                return false;
            }
        }else if(storageArea == null && storageLocation != null){
            //存储区域为空，存储位置不为空，判断子批次的存储位置是否与处方中设置的存储位置一致
            if(!storageLocation.equals(locationStr)){
                ProductPhaseSwingHelper.showErrorDlg(msg);
                return false;
            }
        }else if(storageArea != null && storageLocation == null){
            //存储区域不为空，存储位置为空，判断子批次的存储区域是否与处方中设置的存储区域一致
            if(!storageArea.equals(parentLocationStr)){
                ProductPhaseSwingHelper.showErrorDlg(msg);
                return false;
            }
        }
        return true;
    }


//    private static IMFCService getMFCService() {
//        return (IMFCService)ServiceFactory.getService(IMFCService.class);
//    }
//
//    private static IdentificationResult identifySublotForOSIAndSplitIfNecessary1(final Sublot sublot, final String sublotBarcode, final OrderStepInputPosition osiPosition, final List<IESignatureExecutor> signaturesException, final IESignatureExecutor signatureManualIdentification, final List<String> sublotCheckNames, final IIdentificationCheckSuite theCheckSuite, final TransactionHistoryContext thContext, final List<String> theSignedExceptions, final boolean saveSignatureExecutor) throws MESException, DatasweepException {
//        long var10 = 0L;
//        if (sublot == null && sublotBarcode == null) {
//            throw new IllegalArgumentException("one of sublot and sublotBarcode must not be null");
//        } else {
//            //assertOrderStepInputNotNull(osiPosition);
//            OrderStepInput var12 = osiPosition.getOriginOSI();
//            DataBaseLockUtility.acquireDBLock(var12.getOrderStep());
//            Sublot var13 = null;
//            if (sublot != null) {
//                var13 = sublot;
//            } else {
//                var13 = getMFCService().getSublotFromBarcode(sublotBarcode);
//                if (var13 == null) {
//                    throw new MESRuntimeException("No sublot found for barcode: <" + sublotBarcode + ">");
//                }
//            }
//
//            ((ISublotService)ServiceFactory.getService(ISublotService.class)).setSublotIdentificationMode(var13, var10);
//            IIdentificationCheckSuite var14;
//            if (theCheckSuite != null) {
//                var14 = getMFCService().performIdentificationChecksForSublot(var13, var12, theCheckSuite);
//            } else if (sublotCheckNames != null) {
//                var14 = getMFCService().performIdentificationChecksForSublot(var13, var12, sublotCheckNames);
//            } else {
//                var14 = getMFCService().performIdentificationChecksForSublot(var13, var12);
//            }
//
//            ((ISublotService)ServiceFactory.getService(ISublotService.class)).setSublotIdentificationMode(var13, (Long)null);
//            if (!var14.hasErrors() && (!var14.hasExceptionsButNoErrors() || signaturesException != null)) {
//                if (var10 == 0L) {
//                    Long var15 = MESNamedUDASublot.getLoadCarrierKey(sublot);
//                    if (var15 != null) {
//                        throw new MESRuntimeException("Container identification not supported");
//                    }
//                }
//
//                return new IdentificationResult(var14);
//            } else {
//                return new IdentificationResult(var14);
//            }
//        }
//    }
//
//
//
//    public static Map<Sublot, IdentificationResult> identifySublotsForOSIsAndSplitIfNecessary(final List<IdentificationSublot> sublotData) throws MESException, DatasweepException {
//        HashMap var1 = new HashMap();
//        boolean var2 = false;
//        boolean var3 = false;
//        boolean var4 = false;
//        Iterator var5 = sublotData.iterator();
//
//        while(var5.hasNext()) {
//            IdentificationSublot var6 = (IdentificationSublot)var5.next();
//            if (!var5.hasNext()) {
//                var4 = true;
//            }
//
//            IdentificationResult var7 = identifySublotForOSIAndSplitIfNecessary1(var6.getSublot(), var6.getSublotBarcode(), var6.getOsiPosition(), var6.getSignaturesException(), var6.getSignatureManualIdentification(), (List)null,var6.getCheckSuite(), (TransactionHistoryContext)null,var6.getSignedExceptions(), var4);
//            var1.put(var6.getSublot(), var7);
//            if (!var2 && var7.getIdentificationCheckSuite().hasErrors()) {
//                var2 = true;
//            }
//
//            if (!var3 && !var7.getIdentificationCheckSuite().getExceptionList().isEmpty()) {
//                var3 = true;
//            }
//        }
//
//        if (!var2 && !var3) {
//            return var1;
//        } else {
//            throw new MESMultipleSublotsIdentificationException(var1);
//        }
//    }

    /**
    手动识别子批次
     */
    @Override
    public void onManualIdent(String itemId) {
        try {
            if (noFurtherIdentifcation()) {
                showMustLoopError();
                return;
            }
            //子批次校验
            identifiedItem = getIdentifiedItemByIdentifier(itemId);
            final boolean onPostAction = false;
            IPhaseIdentificationCheckSuite0710 checkSuite = executePreChecks(onPostAction);
            /*
            tanxin
            LC
            手动录入子批次也要校验是否符合规定
             */
            if(getMaterialPosiControl().getEnable()){
                if(!CheckMaterialLocationRule()){
                    return;
                }
                displayException(KEY_MANUAL_EXC, checkSuite);
                return;
            }
            if(getMixCheckConfiguration().getEnabled()){
                //开启，判断子批次与表格中的子批次是否为同一组物料或同一个物料
                CheckMaterialRule(2);
                displayException(KEY_MANUAL_EXC, checkSuite);
                return;
            }
            displayException(KEY_MANUAL_EXC, checkSuite);
        } catch (MESException e1) {
            ProductPhaseSwingHelper.showErrorDlg(e1.getLocalizedMessage());
            return;
        }
    }

    @Override
    public void onUndoIdent(String itemId) {
        undo(itemId, false);
    }

    @Override
    public void onAdditionalIdent(String itemId) {
        // get item ID by user input
        try {
            identifiedItem = getIdentifiedItemByIdentifier(itemId);
            final boolean onPostAction = true;
            IPhaseIdentificationCheckSuite0710 checkSuite = executePreChecks(onPostAction);
            displayException(KEY_ADDITIONAL_ACTION, checkSuite);
        } catch (MESException e1) {
            ProductPhaseSwingHelper.showErrorDlg(e1.getLocalizedMessage());
            return;
        }
    }

    @Override
    public void onUndoIdentAction(String itemId) {
        undo(itemId, true);
    }

    private void undo(String itemId, boolean isAction) {
        // get identified item by user input
        try {
            identifiedItem = getIdentifiedItemByIdentifier(itemId);
        } catch (MESException e1) {
            ProductPhaseSwingHelper.showErrorDlg(e1.getLocalizedMessage());
            return;
        }

        try {
            checkForUndo();
        } catch (MESIncompatibleUoMException e) {
            ProductPhaseSwingHelper.showErrorDlg(e.getLocalizedMessage());
            return;
        } catch (RtPhaseExecutorMatAlterIdent0010.UndoCheckFailedException e) {
            // show the error as a dialog
            if (StringUtils.isNotEmpty(e.getDetailedMessage())) {
                new ErrorDialogWithDetails().showDialog(e.getLocalizedMessage(), e.getDetailedMessage());
            } else {
                ProductPhaseSwingHelper.showErrorDlg(e.getLocalizedMessage());
            }
            return;
        }
        displayException(isAction ? KEY_UNDO_ACTION : KEY_UNDO_EXC, null);
    }


    private boolean displayException(String checkKey, IPhaseIdentificationCheckSuite0710 checkSuite) {
        if (checkSuite != null && !checkSuite.getCollectedErrorMessage().isEmpty()) {
            if (identifiedItem.isLogisticUnit()) {
                // in case of logistic unit the error list can be quite long
                // therefore we use error dialog with details
                final String errorMsg = I18nMessageUtility.getLocalizedMessage(MSG_PACK, "LUCannotIdentifyErrors_ErrorMsg", new String[]{identifiedItem.getName()});
                new ErrorDialogWithDetails().showDialog(errorMsg, checkSuite.getCollectedErrorMessage());
            } else {
                ProductPhaseSwingHelper.showErrorDlg(checkSuite.getCollectedErrorMessage());
            }
            return false;
        }

        StringBuilder buffer = new StringBuilder();
        long riskClass = getActionInfo(checkKey, buffer);
        // add the sublot id to the message
        String message = buffer.toString();

        if (checkSuite != null && !checkSuite.getCollectedExceptionMessage().isEmpty()) {
            // show exception dialog for the user to decide whether to continue with the action
            String exceptions = checkSuite.getCollectedExceptionMessage();
            PhaseWarningDialog excDialog = new PhaseWarningDialog();
            int userChoice = excDialog.showDialog(exceptions);
            if (userChoice != IExceptionHandler.OK_OPTION) {
                return false;
            }
            // compose a message from all identify exceptions and the message of the defined exception
            buffer = new StringBuilder();
            buffer.append(checkSuite.getCollectedExtendedExceptionMessage());
            buffer.append(StringConstants.LINE_BREAK);
            buffer.append(StringConstants.LINE_BREAK);
            buffer.append(message);
            message = buffer.toString();

            // get the higher risk
            riskClass = Math.max(riskClass, checkSuite.getCollectedMaxRisk());
        }

        return displayException(checkKey, ChoiceLists0710.getRiskClass(riskClass), message);
    }

    private long getActionInfo(String checkKey, StringBuilder buffer) {
        Object[] params;
        if (checkKey.equals(KEY_UNDO_ACTION) || checkKey.equals(KEY_UNDO_EXC)) {
            params = buildParamsForUndo();
        } else {
            params = new Object[]{identifiedItem.getDisplayString()};
        }
        String messageId;
        String parameterName;
        switch (checkKey) {
            case KEY_ADDITIONAL_ACTION:
                parameterName = ParamClassConstants0400.PARAMETER_ADDITIONAL_ACTN;
                messageId = identifiedItem.isLogisticUnit() ? "LUAdditionalIdentMsg" : "AdditionalIdentMsg";
                break;
            case KEY_MANUAL_EXC:
                parameterName = ParamClassConstants0400.PARAMETER_MANUAL_EXC;
                messageId = identifiedItem.isLogisticUnit() ? "LUIdentMsg" : "IdentMsg";
                break;
            case KEY_UNDO_ACTION:
                parameterName = ParamClassConstants0400.PARAMETER_UNDO_ACTN;
                messageId = identifiedItem.isLogisticUnit() ? "LUUndoIdentMsg" : "UndoIdentMsg";
                break;
            case KEY_UNDO_EXC:
                parameterName = ParamClassConstants0400.PARAMETER_UNDO_EXC;
                messageId = identifiedItem.isLogisticUnit() ? "LUUndoIdentMsg" : "UndoIdentMsg";
                break;
            default:
                throw new MESRuntimeException("Action not supported! ");
        }
        String messageFromParameter = model.getExceptionTextFromParameter(parameterName);
        // message from RecipeDesigner
        if (messageFromParameter != null) {
            buffer.append(messageFromParameter);
        }
        appendMessage(buffer, messageId, params);
        return model.getExceptionRiskFromParameter(parameterName).longValue();
    }

    private Object[] buildParamsForUndo() {
        Object[] params;
        if (identifiedItem.isLogisticUnit()) {
            // for undo identification of logistic unit it can be that not all sublots of the logistic unit
            // are unidentified
            List<String> sublotsDisplayString = new ArrayList<>();
            for (Sublot sublot : sublotsForUndoLUIdentification) {
                String displayStringSublot = I18nMessageUtility.getLocalizedMessage(MSG_PACK, "LUUndoIdentSublotElementMsg", new Object[]{sublot.getUniqueName(), getQtyDisplayString(sublot)});
                sublotsDisplayString.add(displayStringSublot);
            }
            final String displayString = identifiedItem.getLogisticUnit() //
                    + StringConstants.LINE_BREAK //
                    + StringUtilsEx.buildSeparatedListForUI(sublotsDisplayString, Integer.MAX_VALUE, StringConstants.LINE_BREAK);
            params = new Object[]{displayString};
        } else {
            params = new Object[]{identifiedItem.getDisplayString(), getQtyDisplayString(identifiedItem.getSublot())};
        }

        return params;
    }

    private String getQtyDisplayString(Sublot sublot) {
        return new MeasuredValueWrapper(sublot.getQuantity()).getDrawString();
    }

    private void appendMessage(StringBuilder extendedMessage, String messageId, Object[] msgParams) {
        if (extendedMessage != null) {
            if (extendedMessage.length() > 0) {
                // only add new line if the message is not empty
                extendedMessage.append(StringConstants.LINE_BREAK);
            }

            extendedMessage.append(I18nMessageUtility.getLocalizedMessage(MSG_PACK, messageId, msgParams));
        }
    }

    /**
     * 强制完成按钮
     */
    @Override
    public void onForceCompletion() {
        String messageFromParameter = model.getExceptionTextFromParameter(PARAM_FORCE_COMPLETION);

        StringBuilder buffer = new StringBuilder();
        if (StringUtils.isNoneBlank(messageFromParameter)) {
            buffer.append(messageFromParameter);
            buffer.append(StringConstants.LINE_BREAK);
        }
        buffer.append(I18nMessageUtility.getLocalizedMessage(RtPhaseExecutorMatAlterIdent0010.MSG_PACK, "ForceCompletionExceptionText"));

        String errorText = getCompletionErrors(true);

        if (!StringUtils.isEmpty(errorText)) {
            buffer.append(StringConstants.LINE_BREAK);
            buffer.append(errorText);
        } else {
            ProductPhaseSwingHelper.showErrorDlg(I18nMessageUtility.getLocalizedMessage(RtPhaseExecutorMatAlterIdent0010.MSG_PACK, "NoErrorsToBeForced_Error"));
            return;
        }
        String exceptionText = buffer.toString();
        long risk = model.getExceptionRiskFromParameter(PARAM_FORCE_COMPLETION).longValue();

        displayException(KEY_FORCE_COMPLETION, ChoiceLists0710.getRiskClass(risk), exceptionText);
    }

    @Override
    public void onRefresh() {
        final boolean tryCalculationOfPlannedQty = false;
        refreshModelAndView(tryCalculationOfPlannedQty);
    }

    /**
     * 扫描条码 校验开始
     * @param barcode
     */
    @Override
    protected void handleBarcode(String barcode) {
        super.handleBarcode(barcode);
        getView().getInputField().setText(barcode);
        if (getModel().getStatus().equals(Status.ACTIVE) && getModel().isFocused()) {
            getView().getEventListener().onIdent();
        }
    }

    @Override
    public void onDoneButtonPressed() {
        model.setPhaseResult(PhaseResult0710.DONE);
    }

    @Override
    public void onStopButtonPressed() {
        model.setPhaseResult(PhaseResult0710.STOP);
    }

    @Override
    public void onContinueButtonPressed() {
        model.setPhaseResult(PhaseResult0710.CONTINUE);
    }

}
