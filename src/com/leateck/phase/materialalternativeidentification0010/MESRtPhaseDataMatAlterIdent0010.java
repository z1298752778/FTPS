package com.leateck.phase.materialalternativeidentification0010;

/**
 * This file is generated by the PhaseLibManager
 */
import com.datasweep.compatibility.client.ATRow;
import com.rockwell.mes.commons.base.ifc.utility.StringConstants;
import com.rockwell.mes.services.s88.ifc.processdata.IMESRtPhaseData;
import com.rockwell.mes.shared.product.material.PhaseResult0710;
import org.apache.commons.lang3.BooleanUtils;
import org.apache.commons.lang3.StringUtils;

import java.nio.charset.Charset;

/**
 * Generated class definition
 */
public class MESRtPhaseDataMatAlterIdent0010 extends MESGeneratedRtPhaseDataMatAlterIdent0010 //
                                                  implements IMESRtPhaseData {

    /**
     * Generated method definition
     *
     * @param key The key of the ATRow to load.
     */
    public MESRtPhaseDataMatAlterIdent0010(long key) {
        super(key);
    }

    /**
     * Generated method definition
     *
     * @param source the source to copy.
     */
    public MESRtPhaseDataMatAlterIdent0010(MESRtPhaseDataMatAlterIdent0010 source) {
        super(source);
    }

    /**
     * Generated method definition
     *
     * @param baseATRow The ATRow to wrap.
     */
    public MESRtPhaseDataMatAlterIdent0010(ATRow baseATRow) {
        super(baseATRow);
    }

    /**
     * Generated method definition
     *
     */
    public MESRtPhaseDataMatAlterIdent0010() {
        super();
    }

    /**
     * @return the comment to execution represented as String (needed for batch report)
     */
    public String getCommentToExecutionStr() {
        byte[] commentToExecution = getCommentToExecution();
        if (commentToExecution == null) {
            return null;
        } else {
            return new String(commentToExecution, Charset.defaultCharset());
        }
    }

    /**
     * @return Batch ID of the identified sublot or list of IDs of the allocated batches in header rows represented as
     *         String (needed for batch report)
     */
    public String getBatchIDStr() {
        byte[] batchID = getBatchID();
        if (batchID == null) {
            return null;
        } else {
            return new String(batchID, Charset.defaultCharset());
        }
    }

    /**
     * @param batchName as string
     */
    public void setBatchIDStr(String batchName) {
        if (batchName != null) {
            setBatchID(batchName.getBytes(Charset.defaultCharset()));
        } else {
            setBatchID(null);
        }
    }

    /**
     * @return ID of the identified sublot or list of IDs of the allocated sublots in header rows represented as String
     *         (needed for batch report)
     */
    public String getSublotIDStr() {
        byte[] sublotID = getSublotID();
        if (sublotID == null) {
            return null;
        } else {
            return new String(sublotID, Charset.defaultCharset());
        }
    }

    /**
     * @param sublotIDStr as string
     */
    public void setSublotIDStr(String sublotIDStr) {
        if (sublotIDStr != null) {
            setSublotID(sublotIDStr.getBytes(Charset.defaultCharset()));
        } else {
            setSublotID(null);
        }
    }

    /**
     * @return Batch ID of the identified sublot or list of IDs of the allocated batches in header rows represented as
     *         String (needed for batch report)
     */
    public String getBatchSublotDisplString() {
        byte[] displayStr = getBatchSublotDisplStr();
        if (displayStr == null) {
            return null;
        } else {
            String resultString = new String(displayStr, Charset.defaultCharset());
            if (RtPhaseExecutorMatAlterIdent0010.WORK_AROUND_BLOB_VALUE_FOR_EMPTY.equals(resultString)) {
                return StringUtils.EMPTY;
            }
            return resultString;
        }
    }

    /**
     * @param asString the display string as type string
     */
    public void setBatchSublotDisplString(String asString) {
        if (asString == null) {
            setBatchSublotDisplStr(null);
        } else {
            setBatchSublotDisplStr(asString.getBytes(Charset.defaultCharset()));
        }

    }

    /**
     * @return true if the corresponding sublot has been locally identified by this phase instance
     */
    public boolean isLocalIdentified() {
        // handle localidentified = null as false!
        return BooleanUtils.isFalse(getIsHeader()) && BooleanUtils.isTrue(getLocalIdentified());
    }

    /**
     * @return if result is done
     */
    public boolean isDoneInstance() {
        return PhaseResult0710.DONE.getKey().equals(getResult());
    }

    @Override
    public String toString() {
        String key = "none";
        ATRow atRow = getATRow();
        if (atRow != null) {
            key = Long.toString(atRow.getKey());
        }
        StringBuilder builder = new StringBuilder();
        builder.append(getClass().getSimpleName());
        builder.append(": ").append(key);
        builder.append(" Pos: ").append(getMfcPos());
        builder.append(" isHeader: ").append(getIsHeader());
        builder.append(" plannedQty: ").append(getPlannedQty());
        builder.append(" identifiedQty: ").append(getIdentifiedQty());
        builder.append(" unIdentified: ").append(getIsUnidentified());
        builder.append(" local identified: ").append(isLocalIdentified());
        builder.append(" accounting status: ").append(getAccountingStatus());
        builder.append(" accounted quanatity: ").append(getAccountedQty());
        builder.append(StringConstants.LINE_BREAK);
        builder.append(" BatchSublotDisplString: ").append(getBatchSublotDisplString());
        builder.append(StringConstants.LINE_BREAK);
        builder.append(" batch: ").append(getBatchIDStr());
        builder.append(" sublot: ").append(getSublotIDStr());
        builder.append(StringConstants.LINE_BREAK);

        return builder.toString();
    }
}
