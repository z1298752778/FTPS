// CHECKSTYLE:FileLength:off
package com.leateck.phase.accountalternativematerial0010;

import com.datasweep.compatibility.client.*;
import com.datasweep.plantops.common.measuredvalue.IMeasuredValue;
import com.leateck.phase.accountalternativematerial0010.at.IMESLCLossQtyAccountCon;
import com.leateck.phase.accountalternativematerial0010.at.MESLCLossQtyAccountCon;
import com.leateck.phase.accountalternativematerial0010.at.MESLCLossQtyAccountConFilter;
import com.rockwell.mes.apps.ebr.ifc.phase.IPhaseCompleter;
import com.rockwell.mes.apps.ebr.ifc.phase.PhaseExecutorHelper;
import com.rockwell.mes.apps.ebr.ifc.phase.ui.PhaseDialog;
import com.rockwell.mes.apps.ebr.ifc.phase.ui.PhaseDialog.DialogEvent;
import com.rockwell.mes.apps.ebr.ifc.phase.ui.PhaseQuestionDialog;
import com.rockwell.mes.commons.base.ifc.OSILock;
import com.rockwell.mes.commons.base.ifc.OSILock.LockException;
import com.rockwell.mes.commons.base.ifc.OSILockCollection;
import com.rockwell.mes.commons.base.ifc.exceptions.MESException;
import com.rockwell.mes.commons.base.ifc.exceptions.MESIncompatibleUoMException;
import com.rockwell.mes.commons.base.ifc.exceptions.MESRuntimeException;
import com.rockwell.mes.commons.base.ifc.functional.MeasuredValueUtilities;
import com.rockwell.mes.commons.base.ifc.i18n.I18nMessageUtility;
import com.rockwell.mes.commons.base.ifc.services.PCContext;
import com.rockwell.mes.commons.base.ifc.services.ServiceFactory;
import com.rockwell.mes.commons.base.ifc.ui.DialogHelper;
import com.rockwell.mes.commons.base.ifc.utility.AutoWaitCursor;
import com.rockwell.mes.commons.base.ifc.utility.StringConstants;
import com.rockwell.mes.commons.base.ifc.utility.StringUtilsEx;
import com.rockwell.mes.commons.deviation.ifc.IESignatureExecutor;
import com.rockwell.mes.commons.deviation.ifc.exceptionrecording.IMESExceptionRecord;
import com.rockwell.mes.commons.parameter.exceptiondef.MESParamExceptionDef0300;
import com.rockwell.mes.commons.shared.phase.mvc.AbstractPhaseExceptionView0200;
import com.rockwell.mes.services.inventory.ifc.TransactionSubtype;
import com.rockwell.mes.services.inventory.ifc.exceptions.MESQuantityMustNotBeNegativeException;
import com.rockwell.mes.services.inventory.ifc.exceptions.MESSublotOperationNotAllowedException;
import com.rockwell.mes.services.s88.ifc.IS88SignedActionService;
import com.rockwell.mes.services.s88.ifc.execution.IMESRtPhase;
import com.rockwell.mes.services.s88.ifc.recipe.IMESPhase;
import com.rockwell.mes.services.warehouseintegration.ifc.WarehouseRuntimeException;
import com.rockwell.mes.services.wip.ifc.IOrderStepExecutionService;
import com.rockwell.mes.services.wip.ifc.UpdateAccountStatusOptions;
import com.rockwell.mes.shared.product.material.AbstractMaterialPhaseExecutor0710;
import com.rockwell.mes.shared.product.material.AccountMaterialDAO0710;
import com.rockwell.mes.shared.product.material.AccountMaterialDAO0710.AccountType;
import com.rockwell.mes.shared.product.material.MaterialModel0710;
import com.rockwell.mes.shared.product.material.PhaseResult0710;
import com.rockwell.mes.shared.product.material.messaging.MatIdentMessage0710Controller;
import com.rockwell.mes.shared.product.material.util.MaterialHelper0710;
import com.rockwell.mes.shared0400.product.ui.basics.util.ProductPhaseSwingHelper;

import java.math.BigDecimal;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Allows for accounting the sublots identified in the order step.
 * <p>
 * This runtime phase executor skeleton is generated by the PhaseLibManager.
 * <p>
 *
 * @author ikoleva, (c) Copyright 2014 Rockwell Automation Technologies, Inc. All Rights Reserved.
 */
@SuppressWarnings({"PMD.ExcessiveImports"})
// All imports needed
public class RtPhaseExecutorMatAlterAcct0010 extends
        AbstractMaterialPhaseExecutor0710<MatAccountModel0710, MatAccountView0710, //
                AbstractPhaseExceptionView0200<MatAccountModel0710>, RtPhaseActionViewMatAccount0710>
        implements IMatAccountEventListener0710 {

    /**
     * the check key of the exception when not all sublots are accounted
     */
    public static final String KEY_ACCOUNT_CONGIG_EXC = "AccountConfigException";

    private MatIdentMessage0710Controller messageController;


    /**
     * ctor for an ACTIVE phase or a COMPLETED phase in case of resume.
     *
     * @param inPhaseCompleter the object, which shall be used to complete the phase
     * @param inRtPhase        the runtime phase to be executed
     */
    public RtPhaseExecutorMatAlterAcct0010(IPhaseCompleter inPhaseCompleter, IMESRtPhase inRtPhase) {
        super(inPhaseCompleter, inRtPhase);
    }

    /**
     * ctor for a phase for the PREVIEW.
     *
     * @param inPhase the related phase
     * @param inStep  the related activity set step
     */
    public RtPhaseExecutorMatAlterAcct0010(IMESPhase inPhase, ActivitySetStep inStep) {
        super(inPhase, inStep);
    }

    @Override
    protected void start() {
        messageController = new MatIdentMessage0710Controller(this);
        messageController.startReceivingMessages();
        if (model.isModified()) {
            // the model can be modified on start if it was modified and then PEC was restarted/operation was detached
            // the start method is executed only for an active phase so no marker in the completed view
            getView().setModified();
        }
    }

    private void releaseSublots() {
        List<OrderStepInput> osiList = new ArrayList<>();
        for (AccountMaterialDAO0710 material : model.getMaterialList()) {
            if (material.isHeader() || material.isAccountComplete()) {
                continue;
            }

            osiList.add(material.getOrderStepInput());
        }
        if (osiList.isEmpty()) {
            // all positions were released already, possibly by another phase instance
            return;
        }
        try {
            try (OSILockCollection lockCollection = new OSILockCollection(osiList, getRtPhase())) {
                if (lockCollection.isOwnerChange()) {
                    model.getOrderStep(true);
                }
                IOrderStepExecutionService service = MaterialHelper0710.getOrderStepExecutionService();
                service.releaseOSISublots(osiList);
            }
        } catch (MESIncompatibleUoMException | MESQuantityMustNotBeNegativeException | MESSublotOperationNotAllowedException | DatasweepException
                | LockException exc) {
            throw new MESRuntimeException(exc);
        }
    }

    private void accountSublots(List<AccountMaterialDAO0710> materialRows) {
        model.getOrderStep(true);
        model.refreshMaterialsList();
        List<AccountMaterialDAO0710> rowsToAccount = new ArrayList<>();
        boolean totalConsumption;
        try {
            totalConsumption = initRowsToAccount(materialRows, rowsToAccount);
        } catch (MESException mesExc) {
            return;
        }

        IMeasuredValue identifiedQty = calcTotalQuantity(rowsToAccount);
        if (identifiedQty == null) {
            return;
        }
        accountSublots(rowsToAccount, identifiedQty, totalConsumption);
    }

    private IMeasuredValue calcTotalQuantity(List<AccountMaterialDAO0710> rowsToAccount) {
        String materialID = rowsToAccount.get(0).getMaterialID();
        IMeasuredValue identifiedQty = null;
        for (AccountMaterialDAO0710 accountMaterialDAO : rowsToAccount) {
            if (!accountMaterialDAO.getMaterialID().equals(materialID)) {
                ProductPhaseSwingHelper.showErrorDlg(I18nMessageUtility.getLocalizedMessage(AccountMaterialDAO0710.MSG_PACK, "RowsDiffMaterialTxt"));
                return null;
            }

            identifiedQty = MaterialHelper0710.addMV(identifiedQty, accountMaterialDAO.getIdentifiedQtyMV());
        }
        return identifiedQty;
    }

    /**
     * Initialize the list of all the sublots that should be accounted, based on the user selection
     *
     * @param selectedRows  rows selected by the user in the grid
     * @param rowsToAccount an empty list to be filled with the sublots that should be accounted
     * @return whether total consumption should be performed
     * @throws MESException when there are no sublots to be accounted; error message is displayed in the method
     */
    private boolean initRowsToAccount(List<AccountMaterialDAO0710> selectedRows, List<AccountMaterialDAO0710> rowsToAccount) throws MESException {
        if (selectedRows.isEmpty()) {
            ProductPhaseSwingHelper.showErrorDlg(I18nMessageUtility.getLocalizedMessage(AccountMaterialDAO0710.MSG_PACK, "NoRowSelectedTxt"));
            throw new MESException();
        }

        boolean headerIncluded = false;
        // first gather all the sublots that should be accounted
        for (AccountMaterialDAO0710 accountMaterialDAO : selectedRows) {
            if (accountMaterialDAO.isHeader()) {
                addAllRowsForHeader(rowsToAccount, accountMaterialDAO);
                // if a header is selected total consumption should be performed,
                // even if there is only one sublot
                headerIncluded = true;
            } else {
                // use the row from the model, not the one coming from the view, because the model was refreshed in the
                // meantime
                int indexOfSublot = model.getMaterialList().indexOf(accountMaterialDAO);
                if (indexOfSublot < 0) {
                    ProductPhaseSwingHelper
                            .showErrorDlg(I18nMessageUtility.getLocalizedMessage(AccountMaterialDAO0710.MSG_PACK, "SublotNotIdentified"));
                    throw new MESException();
                }
                AccountMaterialDAO0710 rowFromModel = model.getMaterialList().get(indexOfSublot);
                if (!rowFromModel.isAccountComplete()) {
                    rowsToAccount.add(rowFromModel);
                }
            }
        }

        if (rowsToAccount.isEmpty()) {
            ProductPhaseSwingHelper.showErrorDlg(I18nMessageUtility.getLocalizedMessage(AccountMaterialDAO0710.MSG_PACK, "AllRowsAccountedTxt"));
            throw new MESException();
        }

        return (headerIncluded || rowsToAccount.size() > 1);
    }

    private void addAllRowsForHeader(List<AccountMaterialDAO0710> rowsToAccount, AccountMaterialDAO0710 header) throws MESException {
        // if a material header is selected: check if any sublots are identified
        if (header.getBatch() == null && header.getCountIdentifiedSublots() == 0) {
            ProductPhaseSwingHelper.showErrorDlg(I18nMessageUtility.getLocalizedMessage(AccountMaterialDAO0710.MSG_PACK, "NoSublotsIdentified",
                    new Object[]{header.getMaterialIDStr()}));
            throw new MESException();
        }
        for (AccountMaterialDAO0710 material : model.getMaterialList()) {
            if (material.isHeader() || material.isAccountComplete()) {
                continue;
            }
            if (header.getBatch() != null && header.getBatch().equals(material.getBatch())) {
                rowsToAccount.add(material);
            }
            if (header.getBatch() == null && header.getOsiKey() == material.getOsiKey()) {
                rowsToAccount.add(material);
            }
        }
    }

    /**
     * Account sublots
     *
     * @param sublotsToAccount list of the sublots to be accounted
     * @param identifiedQty    total identified quantity
     * @param totalConsumption whether total consumption should be performed
     */
    private void accountSublots(final List<AccountMaterialDAO0710> sublotsToAccount, final IMeasuredValue identifiedQty,
                                final boolean totalConsumption) {
        final Map<AccountMaterialDAO0710.AccountType, IMeasuredValue> currentQuantities = generateCurrentQtysMap(sublotsToAccount, totalConsumption);

        final AccountQuantitiesDialog0710 dialog =
                new AccountQuantitiesDialog0710(getAccessPrivilegePhaseAction(), PhaseExecutorHelper.getPrivilegeParameterPhaseAction(getPhase()),this);

        if (dialog.showDialog(identifiedQty, !totalConsumption, model.getCalcConfig(), currentQuantities) == DialogEvent.CANCEL_OPTION.getValue()) {
            return;
        }

        WarehouseRuntimeException lastWHException = null;
        List<String> actionInfos = new ArrayList<>();
        try {
            for (final AccountMaterialDAO0710 accountMaterialDAO : sublotsToAccount) {
                final AccountingQuantities quantitiesResult = getQuantitiesForAccount(totalConsumption, accountMaterialDAO, dialog);
                if (!quantitiesResult.success) {
                    return;
                }
                final OrderStepInput osi = accountMaterialDAO.getOrderStepInput();
                try (OSILock osiLock = new OSILock(osi, getRtPhase())) {
                    if (osiLock.isOwnerChange()) {
                        model.getOrderStep(true);
                    }
                    final IOrderStepExecutionService service = MaterialHelper0710.getOrderStepExecutionService();
                    //更改sublot数量,并且修改osi中AccountStatus，QuantityRangeCondition
                    service.setConsumptionQuantities(osi, quantitiesResult.quantities, StringUtilsEx.EMPTY, //
                            new UpdateAccountStatusOptions().updateAccountStatus()
                                    .accountQtyIncludesSampleAndWaste(getModel().getIncludeSampleAndWaste()));
                    // update action info and the accounted qtys in the model after the consumption was performed
                    // successfully
                    actionInfos.add(quantitiesResult.actionInfo);


                    //损耗率=领入量-取样量-废弃量-消耗量

                    IMeasuredValue returnedQty = dialog.getReturnedQuantity();
                    IMeasuredValue destructionMV = null;
                    try {
                        destructionMV = accountMaterialDAO.getIdentifiedQtyMV().subtract(dialog.getSamlpedQuantity())
                                .subtract(dialog.getWastedQuantity())
                                .subtract(dialog.getConsumedQuantity())
                                .subtract(returnedQty);
                        //废弃量= 损耗率+废弃连
                        quantitiesResult.quantities.put(TransactionSubtype.WASTE,quantitiesResult.quantities.get(TransactionSubtype.WASTE).add(destructionMV));

                        saveLossQtyAccountCon(accountMaterialDAO.getSublot(),MeasuredValueUtilities.createMV(destructionMV.toString() ));
                    } catch (Exception e) {
                        e.printStackTrace();
                    }


                    service.setConsumptionQuantities(osi, quantitiesResult.quantities, StringUtilsEx.EMPTY, //
                            new UpdateAccountStatusOptions().updateAccountStatus()
                                    .accountQtyIncludesSampleAndWaste(getModel().getIncludeSampleAndWaste()));
                    // update action info and the accounted qtys in the model after the consumption was performed
                    // successfully
                    actionInfos.add(quantitiesResult.actionInfo);
/*                    try {
                        IMeasuredValue returnedQty = dialog.getReturnedQuantity();
                        IMeasuredValue destructionMV = accountMaterialDAO.getIdentifiedQtyMV().subtract(dialog.getSamlpedQuantity())
                                .subtract(dialog.getWastedQuantity())
                                .subtract(dialog.getConsumedQuantity())
                                .subtract(returnedQty);
                        quantitiesResult.quantities.put(TransactionSubtype.WASTE,quantitiesResult.quantities.get(TransactionSubtype.WASTE).subtract(destructionMV));

                    }catch (Exception e){
                        e.printStackTrace();
                    }*/
                    model.addAccountedInThisPhaseInstance(osi, quantitiesResult.quantities);


                    // reset the signed status for this check key successful accounting:
                    // the state is changed, the user should sign again
                    setExceptionRequested(KEY_ACCOUNT_CONGIG_EXC);

                } catch (MESException | DatasweepException exc) {
                    ProductPhaseSwingHelper.showErrorDlg(exc.getLocalizedMessage());
                    return;
                } catch (LockException exc) {
                    throw new MESRuntimeException(exc);
                } catch (WarehouseRuntimeException e) {
                    actionInfos.add(quantitiesResult.actionInfo);
                    lastWHException = e;
                }
                accountMaterialDAO.setAccounted(true);
            }
        } finally {
            if (dialog.getSignatureExecutor() != null && !actionInfos.isEmpty()) {
                // create an action and update the report data if at least one sublot was updated successfully
                // use the first sublot to retrieve some data that is common to all sublots to be accounted (since they
                // belong
                // to the same material position)
                AccountMaterialDAO0710 firstSublot = sublotsToAccount.get(0);
                // add the material ID as a first row of the action description
                actionInfos.add(0, firstSublot.calculateMatDisplayString());

                // signed action will contain information only about the sublots that were updated successfully
                createSignedAction(dialog.getSignatureExecutor(), actionInfos);
                // pass an empty list of sublots: it is not relevant, we will update just the header
                updateReportData(firstSublot.getMaterialID(), firstSublot.getMfcPosition(), String.valueOf(firstSublot.getOsiKey()),
                        Collections.emptyList(), null, false, true);
            }
            model.setModified(true);
        }

        performAfterAccountSublots(lastWHException);
    }

    private void createSignedAction(IESignatureExecutor signatureExecutor, List<String> actionInfos) {
        String actionDescription = actionInfos.stream().collect(Collectors.joining(StringConstants.NEW_LINE));
        IS88SignedActionService signedActionService = ServiceFactory.getService(IS88SignedActionService.class);
        signedActionService.createAndSaveSignedAction(actionDescription, getRtPhase(), signatureExecutor);
    }

    /**
     * A small class to serve the getQuantitiesForAccount method
     * <p>
     *
     * @author ikoleva, (c) Copyright 2020 Rockwell Automation Technologies, Inc. All Rights Reserved.
     */
    private static class AccountingQuantities {
        private final Boolean success;

        private final Map<TransactionSubtype, IMeasuredValue> quantities;

        private final String actionInfo;

        private AccountingQuantities(Boolean argSuccess, Map<TransactionSubtype, IMeasuredValue> argQuantities, String argActionInfo) {
            this.success = argSuccess;
            this.quantities = argQuantities;
            this.actionInfo = argActionInfo;
        }
    }

    private AccountingQuantities getQuantitiesForAccount(final boolean totalConsumption, final AccountMaterialDAO0710 accountMaterialDAO,
                                                         final AccountQuantitiesDialog0710 dialog) {
        Map<TransactionSubtype, IMeasuredValue> quantities = new HashMap<>();
        Boolean success = Boolean.TRUE;
        // the returned quantity should not be passed to the service that performs the accounting, but should be added
        // to the signature info
        IMeasuredValue returnedQty = null;
        if (totalConsumption) {
            // if total consumption: for each sublot get its entire identified quantity
            quantities.put(TransactionSubtype.CONSUMPTION_INPUT_MATERIAL, accountMaterialDAO.getIdentifiedQtyMV());
            // add 0 quantities for sample and waste because some of the sublots could have been accounted already:
            // the old quantities should be corrected
            quantities.put(TransactionSubtype.SAMPLE,
                    MeasuredValueUtilities.createMV(BigDecimal.ZERO, accountMaterialDAO.getIdentifiedQtyMV().getUnitOfMeasure()));
            quantities.put(TransactionSubtype.WASTE,
                    MeasuredValueUtilities.createMV(BigDecimal.ZERO, accountMaterialDAO.getIdentifiedQtyMV().getUnitOfMeasure()));
            returnedQty = MeasuredValueUtilities.createMV(BigDecimal.ZERO, accountMaterialDAO.getIdentifiedQtyMV().getUnitOfMeasure());
        } else {
            // always add all quantities, even if they are 0,
            // because it could be a correction of the previous qty
            try {
                quantities.put(TransactionSubtype.SAMPLE, dialog.getSamlpedQuantity());
                quantities.put(TransactionSubtype.WASTE, dialog.getWastedQuantity());
                quantities.put(TransactionSubtype.CONSUMPTION_INPUT_MATERIAL, dialog.getConsumedQuantity());
                returnedQty = dialog.getReturnedQuantity();
                //增加废弃量：领入量-退库量-取样量-废弃量
               /* IMeasuredValue destructionMV = accountMaterialDAO.getIdentifiedQtyMV().subtract(dialog.getSamlpedQuantity())
                        .subtract(dialog.getWastedQuantity())
                        .subtract(dialog.getConsumedQuantity())
                        .subtract(returnedQty);
                quantities.put(TransactionSubtype.DESTRUCTION, destructionMV);*/


            } catch (Exception e) {
                ProductPhaseSwingHelper.showErrorDlg(e.getLocalizedMessage());
                success = Boolean.FALSE;
            }
        }
        String consume = MeasuredValueUtilities.toDisplayString(quantities.get(TransactionSubtype.CONSUMPTION_INPUT_MATERIAL));
        String sample = MeasuredValueUtilities.toDisplayString(quantities.get(TransactionSubtype.SAMPLE));
        String waste = MeasuredValueUtilities.toDisplayString(quantities.get(TransactionSubtype.WASTE));
        String ret = MeasuredValueUtilities.toDisplayString(returnedQty);
        String actionInfo = I18nMessageUtility.getLocalizedMessage(AccountMaterialDAO0710.MSG_PACK, "PhaseActionSignatureInfo",
                new String[]{accountMaterialDAO.getBatch(), accountMaterialDAO.getSublot(), consume, sample, waste, ret});

       /* try {
            quantities.put(TransactionSubtype.WASTE, quantities.get(TransactionSubtype.WASTE).add(quantities.get(TransactionSubtype.DESTRUCTION)));

        } catch (Exception e) {
            e.printStackTrace();
        }
        quantities.remove(TransactionSubtype.DESTRUCTION);*/
        return new AccountingQuantities(success, quantities, actionInfo);
    }

    private void performAfterAccountSublots(final WarehouseRuntimeException lastWHException) {
        model.getOrderStep(true);
        model.refreshMaterialsList();

        if (lastWHException != null) {
            model.setLastWarehouseExceptionAndError(lastWHException, "AccountSublotsWarehouseError_Error");
            ProductPhaseSwingHelper.showErrorDlg(model.createWarehouseErrorMessage(AccountMaterialDAO0710.MSG_PACK, null, true));
        }
    }

    /**
     * Generate the map of currently accounted quantities
     *
     * @param sublotsToAccount list of sublots to be accounted
     * @param totalConsumption whether total consumption should be performed
     * @return map containting the currently accounted quantities, null if total consumption or if the sublot was not
     * accounted
     */
    private Map<AccountMaterialDAO0710.AccountType, IMeasuredValue> generateCurrentQtysMap(List<AccountMaterialDAO0710> sublotsToAccount, boolean totalConsumption) {
        Map<AccountMaterialDAO0710.AccountType, IMeasuredValue> currentQuantities = null;
        if (!totalConsumption && sublotsToAccount.get(0).isAccounted()) {
            // fill the map with all current quantities for the sublot to be accounted
            currentQuantities = new EnumMap<>(AccountMaterialDAO0710.AccountType.class);
            for (AccountMaterialDAO0710.AccountType type : AccountMaterialDAO0710.AccountType.values()) {

                currentQuantities.put(type, sublotsToAccount.get(0).getQtyMV(type));
            }
        }
        return currentQuantities;
    }

    @Override
    public void handleOSOCompleted(Long osoKey) {
        handleOSOCompletedOrSublotProducedFor(osoKey);
    }

    @Override
    public void handleSublotProducedFor(Long osoKey) {
        handleOSOCompletedOrSublotProducedFor(osoKey);
    }

    private void handleOSOCompletedOrSublotProducedFor(Long osoKey) {
        if (isOSOPredecessor(osoKey)) {
            // refresh because we have new produced sublots or planned qty might be calculated
            model.getOrderStep(true);
            model.tryCalcPlannedQtyForDynAsProduced();
            model.updateTotalAccountStatus();
            model.initMatInputList();
            model.refreshMaterialsList();
            getView().refreshView();
        }
    }

    @Override
    protected boolean generateReportData() {
        List<MESRtPhaseDataMatAlterAcct0010> data = model.getAllRtPhaseData();
        // check if the entries already exist
        if (data.isEmpty()) {
            for (AccountMaterialDAO0710 material : model.getMatInputList()) {
                // here add only the material headers
                // the subrows will be added on completion in the generateDataRowsForSublots() method because they can
                // change while the phase is active (via the actions in Identify Material)
                MESRtPhaseDataMatAlterAcct0010 rtPhaseData = addRtPhaseData();
                rtPhaseData.setMaterialID(model.createPhaseDataMaterialID(material));
                rtPhaseData.setMaterialDescription(material.getDescription() == null ? " " : material.getDescription());
                rtPhaseData.setMfcPos(material.getMfcPosition());
                rtPhaseData.setIsHeader(material.isHeader());
                rtPhaseData.setIdentifiedQty(MeasuredValueUtilities.toMeasuredValue(material.getIdentifiedQtyMV()));
                rtPhaseData.setConsumedQty(MeasuredValueUtilities.toMeasuredValue(material.getQtyMV(AccountType.CONSUMED)));
                rtPhaseData.setWastedQty(MeasuredValueUtilities.toMeasuredValue(material.getQtyMV(AccountType.WASTED)));
                rtPhaseData.setSampledQty(MeasuredValueUtilities.toMeasuredValue(material.getQtyMV(AccountType.SAMPLED)));
                rtPhaseData.setReturnedQty(MeasuredValueUtilities.toMeasuredValue(material.getQtyMV(AccountType.RETURNED)));
                rtPhaseData.setPlannedQtyWithLimits(material.getPlannedQtyWithLimits());
                rtPhaseData.setAccountingStatus(material.getStatusString());
                rtPhaseData.setResult(model.getPhaseResult().getKey());
            }
        } else {
            for (AccountMaterialDAO0710 material : model.getMatInputList()) {
                data.stream()
                        .filter(dataEntry -> dataEntry.getIsHeader() && dataEntry.getMaterialID().equals(model.createPhaseDataMaterialID(material)))
                        .forEach(dataEntry -> {
                            dataEntry.setIdentifiedQty(MeasuredValueUtilities.toMeasuredValue(material.getIdentifiedQtyMV()));
                            dataEntry.setConsumedQty(MeasuredValueUtilities.toMeasuredValue(material.getQtyMV(AccountType.CONSUMED)));
                            dataEntry.setWastedQty(MeasuredValueUtilities.toMeasuredValue(material.getQtyMV(AccountType.WASTED)));
                            dataEntry.setSampledQty(MeasuredValueUtilities.toMeasuredValue(material.getQtyMV(AccountType.SAMPLED)));
                            dataEntry.setReturnedQty(MeasuredValueUtilities.toMeasuredValue(material.getQtyMV(AccountType.RETURNED)));
                            dataEntry.setPlannedQtyWithLimits(material.getPlannedQtyWithLimits());
                            dataEntry.setAccountingStatus(material.getStatusString());
                            dataEntry.setResult(model.getPhaseResult().getKey());
                        });
            }
        }

        return true;
    }

    /**
     * Add the sublot information to the phase data: one entry per identified sublot
     */
    protected void generateDataRowsForSublots() {
        for (AccountMaterialDAO0710 material : model.getMaterialList()) {
            if (material.isHeader()) {
                // the headers are added in generateReportData()
                continue;
            }
            MESRtPhaseDataMatAlterAcct0010 rtPhaseData = addRtPhaseData();
            rtPhaseData.setMaterialID(model.createPhaseDataMaterialID(material));
            rtPhaseData.setMaterialDescription(material.getDescription() == null ? " " : material.getDescription());
            rtPhaseData.setIsHeader(material.isHeader());
            rtPhaseData.setMfcPos(material.getMaterialMfcPosition());
            rtPhaseData.setBatchID(material.getBatch());
            rtPhaseData.setSublotID(material.getSublot());
            rtPhaseData.setIdentifiedQty(MeasuredValueUtilities.toMeasuredValue(material.getIdentifiedQtyMV()));
            rtPhaseData.setConsumedQty(MeasuredValueUtilities.toMeasuredValue(material.getQtyMV(AccountType.CONSUMED)));
            rtPhaseData.setWastedQty(MeasuredValueUtilities.toMeasuredValue(material.getQtyMV(AccountType.WASTED)));
            rtPhaseData.setSampledQty(MeasuredValueUtilities.toMeasuredValue(material.getQtyMV(AccountType.SAMPLED)));
            rtPhaseData.setReturnedQty(MeasuredValueUtilities.toMeasuredValue(material.getQtyMV(AccountType.RETURNED)));
            rtPhaseData.setResult(model.getPhaseResult().getKey());
        }
    }

    /**
     * @return the number of sublots that were not accounted at all
     */
    public int getUnaccountedSublotsCount() {
        //dustin-20220302,计算sublot未消耗记录，因为增加替代关系，所以需考虑有替代的情况
        int unaccountedSublots = 0;
        for (AccountMaterialDAO0710 matParam : model.getMaterialList()) {
            if (!matParam.isHeader() && !matParam.isAccounted() && !matParam.isAccountComplete()) {
                unaccountedSublots++;
            }
        }
        return unaccountedSublots;
    }

    /**
     * Creates an (additional) runtime phase data object suitable for this type of phase and links it to the runtime
     * phase.
     *
     * @return created phase data instance
     */
    protected final MESRtPhaseDataMatAlterAcct0010 addRtPhaseData() {
        return (MESRtPhaseDataMatAlterAcct0010) getRtPhase().addRtPhaseData();
    }

    /**
     * Gets the current (last) runtime phase data of the runtime phase.
     *
     * @return phase data instance
     */
    protected final MESRtPhaseDataMatAlterAcct0010 getRtPhaseData() {
        return (MESRtPhaseDataMatAlterAcct0010) getRtPhase().getRtPhaseData();
    }

    @Override
    protected void updateDataRows(String materialID, String mfcPosition, String osiNumber, List<Sublot> sublots, String logisticUnitId, boolean add) {
        // just mark the header as modified
        List<MESRtPhaseDataMatAlterAcct0010> dataEntries = model.getAllRtPhaseData();
        String materialIDExt = model.createPhaseDataMaterialID(materialID, osiNumber);
        for (MESRtPhaseDataMatAlterAcct0010 data : dataEntries) {
            if (data.getIsHeader() && materialIDExt.equals(data.getMaterialID())) {
                data.setIsModified(true);
            }
        }
    }

    @Override
    protected MatAccountModel0710 createModel() {
        return new MatAccountModel0710(this);
    }

    @Override
    protected MatAccountView0710 createView(MatAccountModel0710 theModel) {
        return new MatAccountView0710(model, this);
    }

    @Override
    protected MatAccountExceptionView0710 createExceptionView(MatAccountModel0710 theModel) {
        model.initOrderStep();
        return new MatAccountExceptionView0710(model, this);
    }

    @Override
    protected RtPhaseActionViewMatAccount0710 createActionView(MatAccountModel0710 theModel) {
        model.initOrderStep();
        return new RtPhaseActionViewMatAccount0710(model);
    }

    @Override
    protected void performPhaseCompletion() {
        if (messageController != null) {
            messageController.stopReceivingMessages();
        }
        if (model.isPhaseResultDone()) {
            // only release the sublots and complete the OSIs on loop exit
            releaseSublots();
        }
        model.refreshHeaderRowsOnComplete();
        // generate the report data
        generateReportData();
        generateDataRowsForSublots();
        getModel().setPhaseOutputData();
    }

    @Override
    protected boolean performPhaseCompletionCheck() {
        if (model.isBlockedByWarehouseError()) {
            final String signWarehouseErrorText =
                    I18nMessageUtility.getLocalizedMessage(MaterialModel0710.PHASE_PRODUCT_MATERIAL_MSGPACK, "SignWarehouseError_Error");
            ProductPhaseSwingHelper.showErrorDlg(signWarehouseErrorText);
            return false;
        }
        model.getOrderStep(true);
        model.refreshMaterialsList();
        getView().refreshView();
        if (checkForChanges(false)) {
            // clear the history: after the user sees the warning they should be able to complete the phase
            model.clearQtysAccountedInPhaseInstance();
            return false;
        }

        if (model.isPhaseResultDone()) {
            // perform the checks only when on loop exit
            MatAccountCompletionExceptions0710 exceptionsChecker = new MatAccountCompletionExceptions0710(this);
            return exceptionsChecker.checkAndHandleExceptions();

        }
        return true;
    }

    /**
     * 保存损耗量到数据表中
     * @param subNo 子批次号
     * @param lossQty 损耗量
     */
    private void saveLossQtyAccountCon(String subNo, MeasuredValue lossQty){
        Long phaseKey = this.phase.getKey();
        IMESLCLossQtyAccountCon meslcLossQtyAccountCon = filterLossQtyAccountCon(subNo, phaseKey);
        if (meslcLossQtyAccountCon == null) {
            meslcLossQtyAccountCon = new MESLCLossQtyAccountCon();
        }
        meslcLossQtyAccountCon.setSublotNumber(subNo);
        meslcLossQtyAccountCon.setPhaseKey(phaseKey);
        meslcLossQtyAccountCon.setLossQty(MeasuredValueUtilities.createMV(lossQty.toString()));
        meslcLossQtyAccountCon.save(null,"",null);
    }

    /**
     * 查询表中是否已经存在子批次数量了
     * @param subNo
     * @param phaseKey
     * @return
     */
    private IMESLCLossQtyAccountCon filterLossQtyAccountCon(String subNo,Long phaseKey){
        MESLCLossQtyAccountConFilter filter = new MESLCLossQtyAccountConFilter();
        try {
            filter.forPhaseKeyEqualTo(phaseKey);
            filter.forSublotNumberEqualTo(subNo);
        } catch (DatasweepException e) {
            e.printStackTrace();
        }
        List<IMESLCLossQtyAccountCon> filteredObjects = filter.getFilteredObjects();
        if(filteredObjects.size() == 1){
            return filteredObjects.get(0);
        }
        return null;
    }

    private boolean checkForChanges(boolean fromRefreshButton) {
        List<String> modifiedSublots = new ArrayList();
        for (AccountMaterialDAO0710 material : model.getMaterialList()) {
            if (!material.isHeader()) {
                Map<TransactionSubtype, IMeasuredValue> accountedQtys = model.getAccountedInThisPhaseInstance(material.getOrderStepInput());
                try {
                    // if the sublot was accounted in this phase instance: compare the quantities that were entered with
                    // the quantities in the OSI (the material list in the model was refreshed, so it contains
                    // up-to-date info)
                    if (accountedQtys != null && //
                            (MeasuredValueUtilities.compare(material.getQtyMV(AccountType.CONSUMED),
                                    accountedQtys.get(TransactionSubtype.CONSUMPTION_INPUT_MATERIAL)) != 0
                                    || MeasuredValueUtilities.compare(material.getQtyMV(AccountType.SAMPLED),
                                    accountedQtys.get(TransactionSubtype.SAMPLE)) != 0
                                    || MeasuredValueUtilities.compare(material.getQtyMV(AccountType.WASTED),
                                    accountedQtys.get(TransactionSubtype.WASTE)) != 0)) {
                        modifiedSublots.add(material.getSublot());
                    }
                } catch (MESIncompatibleUoMException e) {
                    throw new MESRuntimeException(e);
                }
            }
        }
        if (!modifiedSublots.isEmpty()) {
            String messageID = fromRefreshButton ? "ModificationsDetectedOnRefresh" : "ModificationsDetectedOnComplete";
            String modifiedSLs = modifiedSublots.stream().collect(Collectors.joining(", "));
            LOGGER.warn("Some sublots accounted in this instance were accounted in another instance afterwards: " + modifiedSLs);
            final String sublotsModifiedWarning =
                    I18nMessageUtility.getLocalizedMessage(AccountMaterialDAO0710.MSG_PACK, messageID, new Object[]{modifiedSLs});
            PhaseDialog msgBox = new WarningDialog();
            msgBox.showDialog(sublotsModifiedWarning);
        }
        return !modifiedSublots.isEmpty();
    }

    /**
     * Warning dialog with only an OK button
     * <p>
     *
     * @author ikoleva, (c) Copyright 2020 Rockwell Automation Technologies, Inc. All Rights Reserved.
     */
    @SuppressWarnings("serial")
    private static class WarningDialog extends PhaseDialog {
        private WarningDialog() {
            super(DialogType.WARNING);
            addCloseButtonProtected(OK_MSG, com.rockwell.mes.clientfw.pec.ifc.dialog.DialogEvent.OK_OPTION);
        }
    }

    @Override
    protected void exceptionTransactionCallback(String checkKey, IMESExceptionRecord exceptionRecord, IESignatureExecutor sigExecutor) {
        // nothing to do here for now
    }

    @Override
    public void exceptionSigned(String checkKey) {
        if (AbstractMaterialPhaseExecutor0710.WAREHOUSE_ERROR_CHECK_KEY.equals(checkKey)) {
            try (AutoWaitCursor waitCursor = new AutoWaitCursor(getView())) {
                getModel().resetLastWarehouseExceptionAndError();
                // do not auto-complete: the phase performs actions that could cause a WH error before completion
            }
        } else if (MatAccountCompletionExceptions0710.isCompletionCheck(checkKey)) {
            try (AutoWaitCursor waitCursor = new AutoWaitCursor(getView())) {
                triggerAutoCompleteAfterReturnFromExceptionView();
            }
        }
    }

    @Override
    public void onRefresh() {
        model.getOrderStep(true);
        model.refreshMaterialsList();
        checkForChanges(true);
        getView().refreshView();
        model.clearQtysAccountedInPhaseInstance();
    }

    @Override
    public void onAccount() {
        if (model.isBlockedByWarehouseError()) {
            final String signWarehouseErrorText =
                    I18nMessageUtility.getLocalizedMessage(MaterialModel0710.PHASE_PRODUCT_MATERIAL_MSGPACK, "SignWarehouseError_Error");
            ProductPhaseSwingHelper.showErrorDlg(signWarehouseErrorText);
            return;
        }
        accountSublots(getView().getChangedRows());
        getView().refreshView();
        if (model.isModified()) {
            getView().setModified();
        }
    }

    @Override
    public void onWarehouseErrorRecordRequest() {
        model.fillRecordWarehouseErrorException(AccountMaterialDAO0710.MSG_PACK, null);
    }

    @Override
    public void onDoneButtonPressed() {
        model.setPhaseResult(PhaseResult0710.DONE);
    }

    @Override
    public void onContinueButtonPressed() {
        model.setPhaseResult(PhaseResult0710.CONTINUE);
    }

    @Override
    public void onStopButtonPressed() {
        model.setPhaseResult(PhaseResult0710.STOP);
    }
}
